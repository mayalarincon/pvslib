(quotient_rings_with_one
 (IMP_quotient_rings_TCC1 0
  (IMP_quotient_rings_TCC1-1 nil 3908358522
   ("" (lemma "fullset_is_ring_with_one")
    (("" (expand "ring_with_one?") (("" (assert) nil nil)) nil)) nil)
   ((ring_with_one? const-decl "bool" ring_with_one_def nil)
    (fullset_is_ring_with_one formula-decl nil quotient_rings_with_one
     nil))
   nil
   (IMP_quotient_rings assuming
    "quotient_rings[quotient_rings_with_one.T, quotient_rings_with_one.+, quotient_rings_with_one.*, quotient_rings_with_one.zero].quotient_rings"
    "fullset_is_ring: ASSUMPTION ring_def[quotient_rings.T, quotient_rings.+, quotient_rings.*, quotient_rings.zero].ring?(sets[quotient_rings.T].fullset)")))
 (IMP_ring_with_one_ideal_TCC1 0
  (IMP_ring_with_one_ideal_TCC1-1 nil 3908358522
   ("" (lemma "fullset_is_ring_with_one") (("" (propax) nil nil)) nil)
   ((fullset_is_ring_with_one formula-decl nil quotient_rings_with_one
     nil))
   nil
   (IMP_ring_with_one_ideal assuming
    "ring_with_one_ideal[quotient_rings_with_one.T, quotient_rings_with_one.+, quotient_rings_with_one.*, quotient_rings_with_one.zero, quotient_rings_with_one.one].ring_with_one_ideal"
    "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_with_one_ideal.T, ring_with_one_ideal.+, ring_with_one_ideal.*, ring_with_one_ideal.zero, ring_with_one_ideal.one].ring_with_one?(sets[ring_with_one_ideal.T].fullset)")))
 (quotient_ring_with_one_TCC1 0
  (quotient_ring_with_one_TCC1-1 nil 3780573108
   ("" (skeep)
    (("" (inst 1 "I!1") (("" (rewrite "ideal_is_coset") nil nil)) nil))
    nil)
   ((T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (coset? const-decl "bool" cosets_def nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (zero formal-const-decl "T" quotient_rings_with_one nil)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ring_with_one? const-decl "bool" ring_with_one_def nil)
    (ring? const-decl "bool" ring_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (coset type-eq-decl nil cosets_def nil)
    (I!1 skolem-const-decl "ideal[T, +, *, zero](R)"
     quotient_rings_with_one nil)
    (R skolem-const-decl "(ring_with_one?[T, +, *, zero, one])"
     quotient_rings_with_one nil)
    (ideal_is_coset formula-decl nil ring_cosets_lemmas nil)
    (ring nonempty-type-eq-decl nil ring nil))
   nil
   (quotient_ring_with_one existence ""
    "cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)")))
 (quotient_ring_with_one_TCC2 0
  (quotient_ring_with_one_TCC2-1 nil 3780573108
   ("" (skeep*)
    (("" (lemma "coset_add")
      (("" (inst -1 "R" "I!1" "x1`1" "x1`2") (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((zero formal-const-decl "T" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (coset_add formula-decl nil quotient_rings nil)
    (coset type-eq-decl nil cosets_def nil)
    (coset? const-decl "bool" cosets_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ring_with_one? const-decl "bool" ring_with_one_def nil)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (ring? const-decl "bool" ring_def nil)
    (set type-eq-decl nil sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (quotient_ring_with_one subtype
    "cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].add(quotient_rings_with_one.R, quotient_rings_with_one.I)"
    "[[cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I), cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)] -> cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)]")))
 (quotient_ring_with_one_TCC3 0
  (quotient_ring_with_one_TCC3-1 nil 3780573108
   ("" (skeep*)
    (("" (lemma "coset_product")
      (("" (inst -1 "R" "I!1" "x1`1" "x1`2") (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((zero formal-const-decl "T" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (coset_product formula-decl nil quotient_rings nil)
    (coset type-eq-decl nil cosets_def nil)
    (coset? const-decl "bool" cosets_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ring_with_one? const-decl "bool" ring_with_one_def nil)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (ring? const-decl "bool" ring_def nil)
    (set type-eq-decl nil sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (quotient_ring_with_one subtype
    "product_coset_def[quotient_rings_with_one.T, quotient_rings_with_one.+, quotient_rings_with_one.*].product(quotient_rings_with_one.R, quotient_rings_with_one.I)"
    "[[cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I), cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)] -> cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)]")))
 (quotient_ring_with_one_TCC4 0
  (quotient_ring_with_one_TCC4-1 nil 3780573108
   ("" (skeep) (("" (rewrite "ideal_is_coset") nil nil)) nil)
   ((ideal_is_coset formula-decl nil ring_cosets_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring? const-decl "bool" ring_def nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ring_with_one? const-decl "bool" ring_with_one_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (zero formal-const-decl "T" quotient_rings_with_one nil))
   nil
   (quotient_ring_with_one subtype "quotient_rings_with_one.I"
    "cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)")))
 (quotient_ring_with_one_TCC5 0
  (quotient_ring_with_one_TCC5-1 nil 3780573108
   ("" (skeep)
    (("" (rewrite "lcoset_iff_coset" :dir rl)
      (("" (expand "left_coset?")
        (("" (inst 1 "one")
          (("" (typepred "R")
            (("" (expand "ring_with_one?")
              (("" (expand "monoid?")
                (("" (expand "monad?")
                  (("" (expand "member") (("" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (+ const-decl "set[T]" cosets_def nil)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ring? const-decl "bool" ring_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ring_with_one? const-decl "bool" ring_with_one_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (zero formal-const-decl "T" quotient_rings_with_one nil)
    (R skolem-const-decl "(ring_with_one?[T, +, *, zero, one])"
     quotient_rings_with_one nil)
    (monad? const-decl "bool" monad_def nil)
    (member const-decl "bool" sets nil)
    (monoid? const-decl "bool" monoid_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (left_coset? const-decl "bool" cosets_def nil))
   nil
   (quotient_ring_with_one subtype
    "(cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].+)(quotient_rings_with_one.one, quotient_rings_with_one.I)"
    "cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)")))
 (quotient_ring_with_one 0
  (quotient_ring_with_one-1 nil 3780573164
   ("" (skosimp)
    (("" (expand "ring_with_one?")
      (("" (split)
        (("1" (rewrite "quotient_group_is_ring") nil nil)
         ("2" (expand "monoid?")
          (("2" (split)
            (("1" (expand "monad?")
              (("1" (lemma "quotient_group_is_ring")
                (("1" (inst?)
                  (("1" (expand "ring?")
                    (("1" (flatten)
                      (("1" (hide -1 -3 -4 -5)
                        (("1" (assert)
                          (("1" (expand "restrict")
                            (("1" (split)
                              (("1"
                                (hide -1)
                                (("1"
                                  (expand "/")
                                  (("1"
                                    (rewrite
                                     "lcoset_iff_coset"
                                     :dir
                                     rl)
                                    (("1"
                                      (expand "left_coset?")
                                      (("1"
                                        (inst 1 "one")
                                        (("1"
                                          (typepred "R!1")
                                          (("1"
                                            (expand "ring_with_one?")
                                            (("1"
                                              (expand "monoid?")
                                              (("1"
                                                (expand "monad?")
                                                (("1"
                                                  (expand "member")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand "identity?")
                                (("2"
                                  (hide -1)
                                  (("2"
                                    (skosimp)
                                    (("2"
                                      (typepred "x!1")
                                      (("2"
                                        (expand "coset?")
                                        (("2"
                                          (expand "left_coset?")
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (skosimp)
                                              (("2"
                                                (hide -2 -3)
                                                (("2"
                                                  (replaces -1)
                                                  (("2"
                                                    (rewrite
                                                     "product_charac")
                                                    (("1"
                                                      (rewrite
                                                       "product_charac")
                                                      (("1"
                                                        (typepred
                                                         "R!1")
                                                        (("1"
                                                          (expand
                                                           "ring_with_one?")
                                                          (("1"
                                                            (expand
                                                             "monoid?")
                                                            (("1"
                                                              (expand
                                                               "monad?")
                                                              (("1"
                                                                (expand
                                                                 "member")
                                                                (("1"
                                                                  (propax)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide 2)
                                                      (("2"
                                                        (typepred
                                                         "R!1")
                                                        (("2"
                                                          (expand
                                                           "ring_with_one?")
                                                          (("2"
                                                            (expand
                                                             "monoid?")
                                                            (("2"
                                                              (expand
                                                               "monad?")
                                                              (("2"
                                                                (expand
                                                                 "member")
                                                                (("2"
                                                                  (propax)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (lemma "quotient_group_is_ring")
              (("2" (inst?)
                (("2" (inst -1 "I!1")
                  (("2" (expand "ring?") (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ring_with_one? const-decl "bool" ring_with_one_def nil)
    (monoid? const-decl "bool" monoid_def nil)
    (monad? const-decl "bool" monad_def nil)
    (member const-decl "bool" sets nil)
    (/ const-decl "setof[set[T]]" cosets_def nil)
    (left_coset? const-decl "bool" cosets_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (R!1 skolem-const-decl "(ring_with_one?)" quotient_rings_with_one
     nil)
    (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)
    (+ const-decl "set[T]" cosets_def nil)
    (coset? const-decl "bool" cosets_def nil)
    (coset type-eq-decl nil cosets_def nil)
    (setof type-eq-decl nil defined_types nil)
    (TRUE const-decl "bool" booleans nil)
    (one_times formula-decl nil ring_with_one nil)
    (times_one formula-decl nil ring_with_one nil)
    (product_charac formula-decl nil quotient_rings nil)
    (identity? const-decl "bool" operator_defs nil)
    (restrict const-decl "R" restrict nil)
    (quotient_group_is_ring formula-decl nil quotient_rings nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring? const-decl "bool" ring_def nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (zero formal-const-decl "T" quotient_rings_with_one nil))
   nil))
 (fullset_quot_ring_with_one 0
  (fullset_quot_ring_with_one-1 nil 3811152348
   ("" (skeep)
    (("" (expand "ring_with_one?")
      (("" (split)
        (("1" (rewrite "fullset_quot_group_is_ring") nil nil)
         ("2" (lemma "quotient_ring_with_one")
          (("2" (inst -1 "R" "I!1")
            (("2" (expand "ring_with_one?")
              (("2" (flatten)
                (("2" (hide -1)
                  (("2" (expand "monoid?")
                    (("2" (expand "monad?")
                      (("2" (flatten)
                        (("2" (split)
                          (("1" (hide-all-but (-1 1))
                            (("1" (grind) nil nil)) nil)
                           ("2" (hide-all-but (-2 1))
                            (("2" (grind) nil nil)) nil)
                           ("3" (hide-all-but (-3 1))
                            (("3" (expand "identity?")
                              (("3"
                                (skeep)
                                (("3"
                                  (expand "restrict")
                                  (("3"
                                    (inst?)
                                    (("3"
                                      (typepred "x")
                                      (("3"
                                        (expand "restrict")
                                        (("3"
                                          (expand "/")
                                          (("3" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("4" (hide-all-but (-4 1))
                            (("4" (expand "associative?")
                              (("4"
                                (skeep)
                                (("4"
                                  (expand "restrict")
                                  (("4"
                                    (inst?)
                                    (("1"
                                      (typepred "z")
                                      (("1"
                                        (expand "restrict")
                                        (("1"
                                          (expand "/")
                                          (("1" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (expand "restrict")
                                      (("2"
                                        (expand "/")
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (expand "restrict")
                                      (("3"
                                        (expand "/")
                                        (("3" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ring_with_one? const-decl "bool" ring_with_one_def nil)
    (quotient_ring_with_one formula-decl nil quotient_rings_with_one
     nil)
    (monad? const-decl "bool" monad_def nil)
    (lc_gen const-decl "T" cosets_def nil)
    (lproduct const-decl "set[T]" product_coset_def nil)
    (product const-decl "set[T]" product_coset_def nil)
    (fullset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (star_closed? const-decl "bool" groupoid_def nil)
    (identity? const-decl "bool" operator_defs nil)
    (restrict const-decl "R" restrict nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (R skolem-const-decl "(ring_with_one?)" quotient_rings_with_one
     nil)
    (I!1 skolem-const-decl "ideal[T, +, *, zero](R)"
     quotient_rings_with_one nil)
    (x skolem-const-decl "(fullset[coset[T, +](R, I!1)])"
     quotient_rings_with_one nil)
    (/ const-decl "setof[set[T]]" cosets_def nil)
    (setof type-eq-decl nil defined_types nil)
    (coset type-eq-decl nil cosets_def nil)
    (coset? const-decl "bool" cosets_def nil)
    (associative? const-decl "bool" operator_defs nil)
    (z skolem-const-decl "(fullset[coset[T, +](R, I!1)])"
     quotient_rings_with_one nil)
    (y skolem-const-decl "(fullset[coset[T, +](R, I!1)])"
     quotient_rings_with_one nil)
    (x skolem-const-decl "(fullset[coset[T, +](R, I!1)])"
     quotient_rings_with_one nil)
    (monoid? const-decl "bool" monoid_def nil)
    (fullset_quot_group_is_ring formula-decl nil quotient_rings nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring? const-decl "bool" ring_def nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (zero formal-const-decl "T" quotient_rings_with_one nil))
   nil))
 (one_diff_zero_coset 0
  (one_diff_zero_coset-1 nil 3780573200
   ("" (skeep)
    (("" (rewrite "ideal_w_one_is_R")
      (("" (lemma "self_coset")
        (("" (inst -1 "I!1" "R" "one")
          (("" (expand "member")
            (("" (assert)
              (("" (hide-all-but 1)
                (("" (typepred "I!1")
                  (("" (expand "ideal?")
                    (("" (expand "left_ideal?") (("" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ideal_w_one_is_R formula-decl nil ring_with_one_ideal nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring_with_one? const-decl "bool" ring_with_one_def nil)
    (ring_with_one nonempty-type-eq-decl nil ring_with_one nil)
    (ring? const-decl "bool" ring_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (zero formal-const-decl "T" quotient_rings_with_one nil)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (left_ideal? const-decl "bool" ring_ideal_def nil)
    (member const-decl "bool" sets nil)
    (self_coset formula-decl nil ring_cosets_lemmas nil))
   nil))
 (lcoset_power_prod_nat_TCC1 0
  (lcoset_power_prod_nat_TCC1-1 nil 3908285135
   ("" (skeep)
    (("" (rewrite "lcoset_iff_coset" :dir rl)
      (("" (expand "left_coset?") (("" (inst 1 "a") nil nil)) nil))
      nil))
    nil)
   ((lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (+ const-decl "set[T]" cosets_def nil)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (ring_with_one? const-decl "bool" ring_with_one_def nil)
    (ring? const-decl "bool" ring_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (zero formal-const-decl "T" quotient_rings_with_one nil)
    (left_coset? const-decl "bool" cosets_def nil))
   nil
   (lcoset_power_prod_nat subtype
    "(cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].+)(quotient_rings_with_one.a, quotient_rings_with_one.I)"
    "cosets_def[quotient_rings_with_one.T, quotient_rings_with_one.+].coset(quotient_rings_with_one.R, quotient_rings_with_one.I)")))
 (lcoset_power_prod_nat 0
  (lcoset_power_prod_nat-1 nil 3908285145
   ("" (skolem 1 ("_" "R1" "I1" "a1"))
    (("" (induct "i")
      (("1" (grind) nil nil)
       ("2" (skeep)
        (("2" (expand "power" 1 1)
          (("2" (replaces -1)
            (("2" (lemma "product_charac")
              (("2" (inst -1 "R1" "I1" "a1" "power[T, *, one](a1, j)")
                (("1" (replaces -1)
                  (("1" (expand "power" 1 2) (("1" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (hide 2)
                  (("2" (generalize "j" "j")
                    (("2" (induct "j")
                      (("1" (grind)
                        (("1" (typepred "R1")
                          (("1" (expand "ring_with_one?")
                            (("1" (expand "monoid?")
                              (("1"
                                (expand "monad?")
                                (("1"
                                  (expand "member")
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (expand "power" 1)
                          (("2" (lemma "R_prod_star_closed")
                            (("2" (inst?)
                              (("2"
                                (inst -1 "R1")
                                (("2"
                                  (expand "member")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (hide 2)
        (("3" (rewrite "lcoset_iff_coset" :dir rl)
          (("3" (expand "left_coset?")
            (("3" (inst 1 "one")
              (("3" (typepred "R1")
                (("3" (expand "ring_with_one?")
                  (("3" (expand "monoid?")
                    (("3" (expand "monad?")
                      (("3" (expand "member") (("3" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (hide 2)
        (("4" (skeep)
          (("4" (lemma "coset_product")
            (("4" (inst -1 "R1" "I1" "x1`1" "x1`2")
              (("4" (assert) nil nil)) nil))
            nil))
          nil))
        nil)
       ("5" (hide 2) (("5" (rewrite "ideal_is_coset") nil nil)) nil)
       ("6" (hide 2)
        (("6" (rewrite "lcoset_iff_coset" :dir rl)
          (("6" (expand "left_coset?") (("6" (inst 1 "a1") nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((a1 skolem-const-decl "(R1)" quotient_rings_with_one nil)
    (+ const-decl "set[T]" cosets_def nil)
    (I1 skolem-const-decl "ideal[T, +, *, zero](R1)"
     quotient_rings_with_one nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ring? const-decl "bool" ring_def nil)
    (R1 skolem-const-decl "(ring_with_one?)" quotient_rings_with_one
     nil)
    (ring_with_one? const-decl "bool" ring_with_one_def nil)
    (one formal-const-decl "T" quotient_rings_with_one nil)
    (zero formal-const-decl "T" quotient_rings_with_one nil)
    (* formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (coset? const-decl "bool" cosets_def nil)
    (+ formal-const-decl "[T, T -> T]" quotient_rings_with_one nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-nonempty-type-decl nil quotient_rings_with_one nil)
    (TRUE const-decl "bool" booleans nil)
    (coset type-eq-decl nil cosets_def nil)
    (product const-decl "set[T]" product_coset_def nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (power def-decl "T" monoid_def nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (product_charac formula-decl nil quotient_rings nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (monoid? const-decl "bool" monoid_def nil)
    (member const-decl "bool" sets nil)
    (monad? const-decl "bool" monad_def nil)
    (R_prod_star_closed formula-decl nil ring_basic_properties nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (j skolem-const-decl "nat" quotient_rings_with_one nil)
    (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)
    (left_coset? const-decl "bool" cosets_def nil)
    (coset_product formula-decl nil quotient_rings nil)
    (ideal_is_coset formula-decl nil ring_cosets_lemmas nil))
   shostak)))

