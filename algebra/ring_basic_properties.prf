(ring_basic_properties
 (fullset_is_ring 0
  (fullset_is_ring-1 nil 3706534671 ("" (postpone) nil nil) nil
   shostak))
 (IMP_ring_TCC1 0
  (IMP_ring_TCC1-1 nil 3842434599
   ("" (rewrite fullset_is_ring) nil nil)
   ((fullset_is_ring formula-decl nil ring_basic_properties nil)) nil
   (IMP_ring assuming
    "ring[ring_basic_properties.T, ring_basic_properties.+, ring_basic_properties.*, ring_basic_properties.zero].ring"
    "fullset_is_ring: ASSUMPTION ring_def[ring.T, ring.+, ring.*, ring.zero].ring?(sets[ring.T].fullset)")))
 (zero_is_member_R 0
  (zero_is_member_R-1 nil 3746441338
   ("" (skosimp)
    (("" (expand "member")
      (("" (typepred "R!1")
        (("" (expand "ring?")
          (("" (expand "abelian_group?")
            (("" (expand "group?")
              (("" (expand "monoid?")
                (("" (expand "monad?")
                  (("" (flatten)
                    (("" (hide-all-but (-2 1))
                      (("" (expand "member") (("" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (group? const-decl "bool" group_def nil)
    (monad? const-decl "bool" monad_def nil)
    (monoid? const-decl "bool" monoid_def nil)
    (abelian_group? const-decl "bool" group_def nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (set type-eq-decl nil sets nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (ring? const-decl "bool" ring_def nil))
   shostak))
 (inv_is_member_R 0
  (inv_is_member_R-1 nil 3707057272
   ("" (skosimp)
    (("" (expand "member")
      (("" (typepred "R!1")
        (("" (expand "ring?")
          (("" (expand "abelian_group?")
            (("" (expand "group?")
              (("" (flatten)
                (("" (hide-all-but (-1 -2 -8 1))
                  (("" (expand "inv_exists?")
                    (("" (inst -2 "x!1")
                      (("" (skosimp)
                        (("" (hide -3)
                          (("" (typepred "inv(x!1)")
                            (("" (hide -2)
                              ((""
                                (replace -1 -3 rl)
                                ((""
                                  (hide -1)
                                  ((""
                                    (rewrite "cancel_left_plus")
                                    (("" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (group? const-decl "bool" group_def nil)
    (cancel_left_plus formula-decl nil ring nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (inv_exists? const-decl "bool" group_def nil)
    (abelian_group? const-decl "bool" group_def nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (set type-eq-decl nil sets nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (ring? const-decl "bool" ring_def nil))
   shostak))
 (R_sum_star_closed 0
  (R_sum_star_closed-1 nil 3707058623
   ("" (skosimp)
    (("" (expand "member")
      (("" (typepred "R!1")
        (("" (expand "ring?")
          (("" (expand "abelian_group?")
            (("" (expand "group?")
              (("" (expand "monoid?")
                (("" (expand "monad?")
                  (("" (flatten)
                    (("" (hide-all-but (-1 -11 -12 1))
                      (("" (expand "star_closed?")
                        (("" (inst -1 "x!1" "y!1")
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((member const-decl "bool" sets nil)
    (group? const-decl "bool" group_def nil)
    (monad? const-decl "bool" monad_def nil)
    (star_closed? const-decl "bool" groupoid_def nil)
    (monoid? const-decl "bool" monoid_def nil)
    (abelian_group? const-decl "bool" group_def nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (set type-eq-decl nil sets nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (ring? const-decl "bool" ring_def nil))
   shostak))
 (R_prod_star_closed 0
  (R_prod_star_closed-1 nil 3707059869
   ("" (skosimp)
    (("" (typepred "R!1")
      (("" (expand "ring?")
        (("" (flatten)
          (("" (hide-all-but (-2 -6 -7 1))
            (("" (expand "star_closed?")
              (("" (inst -1 "x!1" "y!1")
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ring? const-decl "bool" ring_def nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (set type-eq-decl nil sets nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (star_closed? const-decl "bool" groupoid_def nil)
    (member const-decl "bool" sets nil))
   shostak))
 (l_plus_zero 0
  (l_plus_zero-1 nil 3797777589
   ("" (skosimp)
    (("" (lemma cancel_right_plus)
      (("" (inst -1 "x!1 + y!1" "x!1" "zero")
        (("" (flatten -1)
          (("" (hide -1)
            (("" (split -1)
              (("1" (lemma plus_zero)
                (("1" (inst -1 "x!1 + y!1")
                  (("1" (hide -3)
                    (("1" (replaces -1 -2)
                      (("1" (lemma cancel_left_plus)
                        (("1" (inst -1 "y!1" "zero" "x!1")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((zero formal-const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (cancel_right_plus formula-decl nil ring nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (right_identity formula-decl nil monad nil)
    (cancel_left_plus formula-decl nil ring nil)
    (plus_zero formula-decl nil ring nil))
   nil))
 (r_plus_zero 0
  (r_plus_zero-1 nil 3797777642
   ("" (skosimp)
    (("" (lemma plus_commutative)
      (("" (inst -1 "y!1" "x!1")
        (("" (replaces -1 -2)
          (("" (lemma l_plus_zero)
            (("" (inst -1 "x!1" "y!1") (("" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((zero formal-const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (plus_commutative formula-decl nil ring nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (l_plus_zero formula-decl nil ring_basic_properties nil))
   nil))
 (no_singleton_nzx 0
  (no_singleton_nzx-1 nil 3797780412
   ("" (skosimp)
    (("" (prop)
      (("1" (expand "singleton")
        (("1" (decompose-equality 1)
          (("1" (iff 1)
            (("1" (prop)
              (("1" (inst 2 "x!1") (("1" (assert) nil nil)) nil)
               ("2" (lemma zero_is_member_R)
                (("2" (inst -1 "S!1")
                  (("2" (expand "member") (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skosimp)
        (("2" (expand "singleton")
          (("2" (decompose-equality -1)
            (("2" (inst -1 "nzx!1")
              (("2" (iff -1)
                (("2" (flatten)
                  (("2" (typepred "nzx!1") (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (ring? const-decl "bool" ring_def nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (member const-decl "bool" sets nil)
    (zero_is_member_R formula-decl nil ring_basic_properties nil)
    (singleton const-decl "(singleton?)" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   nil))
 (card_gt_one_nzx 0
  (card_gt_one_nzx-1 nil 3797780811
   ("" (skeep)
    (("" (prop)
      (("1" (rewrite "card_def[T]" :dir rl)
        (("1" (lemma "card_2_has_2[T]")
          (("1" (inst?)
            (("1" (assert)
              (("1" (skeep)
                (("1" (case "x = zero")
                  (("1" (inst 2 "y") (("1" (assert) nil nil)) nil)
                   ("2" (inst 3 "x") (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (typepred "nzx")
          (("2" (lemma zero_is_member_R)
            (("2" (inst?)
              (("2" (expand "member")
                (("2" (rewrite "card_def[T]" :dir rl)
                  (("2" (lemma "card_2_has_2[T]")
                    (("2" (lemma "card_one[T]")
                      (("2" (lemma "empty_card[T]")
                        (("2" (inst?)
                          (("2" (inst?)
                            (("2" (prop)
                              (("1" (assert) nil nil)
                               ("2"
                                (hide-all-but (-1 -4))
                                (("2"
                                  (expand "empty?")
                                  (("2"
                                    (inst -1 "zero")
                                    (("2"
                                      (expand "member")
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (hide -3)
                                (("3"
                                  (expand "singleton")
                                  (("3"
                                    (case
                                     " subset?[T]({y : T | y = zero OR y = nzx} , S) ")
                                    (("1"
                                      (lemma "card_subset[T]")
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (case
                                             "Card({y: T | y = zero OR y = nzx})  = 2")
                                            (("1"
                                              (rewrite
                                               "card_def[T]"
                                               :dir
                                               rl)
                                              (("1" (assert) nil nil))
                                              nil)
                                             ("2"
                                              (hide - 2 3 5)
                                              (("2"
                                                (lemma
                                                 "Card_bijection[T]")
                                                (("2"
                                                  (inst?)
                                                  (("1"
                                                    (prop)
                                                    (("1"
                                                      (inst
                                                       1
                                                       "LAMBDA(t: ({y: T | y = zero OR y = nzx})  ) : IF t = zero THEN 0 ELSE 1 ENDIF ")
                                                      (("1"
                                                        (hide 2 3)
                                                        (("1"
                                                          (expand
                                                           "bijective?")
                                                          (("1"
                                                            (prop)
                                                            (("1"
                                                              (expand
                                                               "injective?")
                                                              (("1"
                                                                (skeep)
                                                                (("1"
                                                                  (typepred
                                                                   "x1")
                                                                  (("1"
                                                                    (typepred
                                                                     "x2")
                                                                    (("1"
                                                                      (lift-if)
                                                                      (("1"
                                                                        (lift-if)
                                                                        (("1"
                                                                          (lift-if)
                                                                          (("1"
                                                                            (prop)
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("2"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("3"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("4"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("5"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("6"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("7"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("8"
                                                                              (assert)
                                                                              nil
                                                                              nil)
                                                                             ("9"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (expand
                                                               "surjective?")
                                                              (("2"
                                                                (skosimp*)
                                                                (("2"
                                                                  (typepred
                                                                   "y!1")
                                                                  (("2"
                                                                    (case
                                                                     "y!1 = 0 OR y!1 = 1")
                                                                    (("1"
                                                                      (prop)
                                                                      (("1"
                                                                        (replaces
                                                                         -1)
                                                                        (("1"
                                                                          (inst
                                                                           1
                                                                           "zero")
                                                                          nil
                                                                          nil))
                                                                        nil)
                                                                       ("2"
                                                                        (replaces
                                                                         -1)
                                                                        (("2"
                                                                          (inst
                                                                           1
                                                                           "nzx")
                                                                          (("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (hide
                                                                       2
                                                                       3)
                                                                      (("2"
                                                                        (prop)
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (expand
                                                     "is_finite")
                                                    (("2"
                                                      (inst
                                                       1
                                                       2
                                                       "LAMBDA(t: ({y: T | y = zero OR y = nzx})  ) : IF t = zero THEN 0 ELSE 1 ENDIF ")
                                                      (("2"
                                                        (expand
                                                         "injective?")
                                                        (("2"
                                                          (skeep)
                                                          (("2"
                                                            (lift-if)
                                                            (("2"
                                                              (lift-if)
                                                              (("2"
                                                                (lift-if)
                                                                (("2"
                                                                  (prop)
                                                                  (("1"
                                                                    (assert)
                                                                    nil
                                                                    nil)
                                                                   ("2"
                                                                    (assert)
                                                                    nil
                                                                    nil)
                                                                   ("3"
                                                                    (assert)
                                                                    nil
                                                                    nil)
                                                                   ("4"
                                                                    (typepred
                                                                     "x1")
                                                                    (("4"
                                                                      (typepred
                                                                       "x2")
                                                                      (("4"
                                                                        (prop)
                                                                        (("4"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (hide-all-but (1 4))
                                              (("3"
                                                (expand "is_finite")
                                                (("3"
                                                  (inst
                                                   1
                                                   2
                                                   "LAMBDA(t: ({y: T | y = zero OR y = nzx})  ) : IF t = zero THEN 0 ELSE 1 ENDIF ")
                                                  (("3"
                                                    (expand
                                                     "injective?")
                                                    (("3"
                                                      (skeep)
                                                      (("3"
                                                        (lift-if)
                                                        (("3"
                                                          (lift-if)
                                                          (("3"
                                                            (lift-if)
                                                            (("3"
                                                              (prop)
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil)
                                                               ("2"
                                                                (assert)
                                                                nil
                                                                nil)
                                                               ("3"
                                                                (assert)
                                                                nil
                                                                nil)
                                                               ("4"
                                                                (typepred
                                                                 "x1")
                                                                (("4"
                                                                  (typepred
                                                                   "x2")
                                                                  (("4"
                                                                    (assert)
                                                                    nil
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (hide-all-but (1 4))
                                          (("2"
                                            (expand "is_finite")
                                            (("2"
                                              (inst
                                               1
                                               2
                                               "LAMBDA(t: ({y: T | y = zero OR y = nzx})  ) : IF t = zero THEN 0 ELSE 1 ENDIF ")
                                              (("2"
                                                (expand "injective?")
                                                (("2"
                                                  (skeep)
                                                  (("2"
                                                    (lift-if)
                                                    (("2"
                                                      (lift-if)
                                                      (("2"
                                                        (lift-if)
                                                        (("2"
                                                          (prop)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("3"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("4"
                                                            (typepred
                                                             "x1")
                                                            (("4"
                                                              (typepred
                                                               "x2")
                                                              (("4"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide-all-but (-3 -4 1))
                                      (("2"
                                        (expand "subset?")
                                        (("2"
                                          (skeep)
                                          (("2"
                                            (expand "member")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("4" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((card_2_has_2 formula-decl nil finite_sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (ring? const-decl "bool" ring_def nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (card_def formula-decl nil finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (card_one formula-decl nil finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (card_subset formula-decl nil finite_sets nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (bijective? const-decl "bool" functions nil)
    (surjective? const-decl "bool" functions nil)
    (TRUE const-decl "bool" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (injective? const-decl "bool" functions nil)
    (Card_bijection formula-decl nil finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (subset? const-decl "bool" sets nil)
    (empty_card formula-decl nil finite_sets nil)
    (member const-decl "bool" sets nil)
    (zero_is_member_R formula-decl nil ring_basic_properties nil))
   nil))
 (no_singleton_card 0
  (no_singleton_card-1 nil 3797780849
   ("" (skosimp)
    (("" (prop)
      (("1" (lemma no_singleton_nzx)
        (("1" (inst -1 "S!1")
          (("1" (assert)
            (("1" (lemma card_gt_one_nzx)
              (("1" (inst -1 "S!1") (("1" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (rewrite "card_def[T]" :dir rl)
        (("2" (lemma card_gt_one_nzx)
          (("2" (inst -1 "S!1")
            (("2" (assert)
              (("2" (skosimp)
                (("2" (expand "singleton")
                  (("2" (decompose-equality -2)
                    (("2" (inst -1 "nzx!1")
                      (("2" (iff -1)
                        (("2" (typepred "nzx!1")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-nonempty-type-decl nil ring_basic_properties nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (ring? const-decl "bool" ring_def nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (is_finite const-decl "bool" finite_sets nil)
    (card_gt_one_nzx formula-decl nil ring_basic_properties nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (no_singleton_nzx formula-decl nil ring_basic_properties nil)
    (singleton const-decl "(singleton?)" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (card_def formula-decl nil finite_sets nil))
   nil))
 (subring_transitive_TCC1 0
  (subring_transitive_TCC1-1 nil 3749913722
   ("" (skosimp) (("" (expand "subring?") (("" (assert) nil nil)) nil))
    nil)
   ((subring? const-decl "bool" ring_def nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil))
   nil
   (subring_transitive subtype "ring_basic_properties.H"
    "(ring_def[ring_basic_properties.T, ring_basic_properties.+, ring_basic_properties.*, ring_basic_properties.zero].ring?)")))
 (subring_transitive 0
  (subring_transitive-1 nil 3749913726
   ("" (skosimp)
    (("" (expand "subring?")
      (("" (flatten)
        (("" (assert)
          (("" (hide -2 -4)
            (("" (lemma "subset_transitive[T]")
              (("" (inst -1 "I!1" "H!1" "R!1") (("" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((subring? const-decl "bool" ring_def nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (subset_transitive formula-decl nil sets_lemmas nil)
    (ring? const-decl "bool" ring_def nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (subring_equiv 0
  (subring_equiv-2 nil 3713800191
   ("" (skosimp)
    (("" (prop)
      (("1" (expand "subring?")
        (("1" (expand "ring?")
          (("1" (expand "abelian_group?")
            (("1" (expand "group?")
              (("1" (expand "monoid?")
                (("1" (expand "monad?")
                  (("1" (flatten)
                    (("1" (hide-all-but (-3 1))
                      (("1" (expand "member")
                        (("1" (expand "nonempty?")
                          (("1" (expand "empty?")
                            (("1" (inst -1 "zero")
                              (("1"
                                (expand "member")
                                (("1" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "subring?") (("2" (assert) nil nil)) nil)
       ("3" (skosimp)
        (("3" (split)
          (("1" (expand "member")
            (("1" (typepred "x!1")
              (("1" (typepred "y!1")
                (("1" (lemma "inv_is_member_R")
                  (("1" (inst -1 "S!1" "y!1")
                    (("1" (assert)
                      (("1" (lemma "R_sum_star_closed")
                        (("1" (inst -1 "S!1" "x!1" "inv(y!1)")
                          (("1" (assert) nil nil)
                           ("2" (expand "subring?")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "subring?") (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (typepred "x!1" "y!1")
            (("2" (rewrite "R_prod_star_closed")
              (("2" (expand "subring?") (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (expand "subring?")
        (("4" (split)
          (("1" (propax) nil nil)
           ("2" (expand "ring?")
            (("2" (expand "abelian_group?")
              (("2" (expand "group?")
                (("2" (expand "monoid?")
                  (("2" (expand "monad?")
                    (("2" (expand "star_closed?")
                      (("2" (split)
                        (("1" (skosimp)
                          (("1" (copy -3)
                            (("1" (inst -1 "x!1" "inv(y!1)")
                              (("1"
                                (flatten)
                                (("1"
                                  (hide -2)
                                  (("1"
                                    (rewrite "negate_negate")
                                    nil
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (copy -3)
                                (("2"
                                  (inst -1 "zero" "y!1")
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (hide -2)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (inst -3 "x!1" "x!1")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "nonempty?")
                          (("2" (expand "empty?")
                            (("2" (skosimp)
                              (("2"
                                (copy -3)
                                (("2"
                                  (inst -1 "x!1" "x!1")
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (hide -2)
                                      (("1"
                                        (expand "member")
                                        (("1"
                                          (rewrite
                                           " negate_is_right_inv")
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "member")
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (expand "identity?")
                          (("3" (skosimp)
                            (("3" (expand "restrict")
                              (("3"
                                (split)
                                (("1" (rewrite "plus_zero") nil nil)
                                 ("2" (rewrite "zero_plus") nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("4" (expand "associative?")
                          (("4" (skosimp)
                            (("4" (expand "restrict")
                              (("4"
                                (rewrite "plus_associative")
                                nil
                                nil))
                              nil))
                            nil))
                          nil)
                         ("5" (expand "inv_exists?")
                          (("5" (skosimp)
                            (("5" (inst 1 "inv(x!1)")
                              (("1"
                                (split)
                                (("1"
                                  (rewrite "negate_is_right_inv")
                                  nil
                                  nil)
                                 ("2"
                                  (rewrite "negate_is_left_inv")
                                  nil
                                  nil))
                                nil)
                               ("2"
                                (copy -3)
                                (("2"
                                  (inst -1 "zero" "x!1")
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (hide -2)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "nonempty?")
                                    (("2"
                                      (expand "empty?")
                                      (("2"
                                        (skosimp)
                                        (("2"
                                          (copy -3)
                                          (("2"
                                            (inst -1 "x!2" "x!2")
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (hide -2)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (expand "member")
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("6" (expand "commutative?")
                          (("6" (skosimp)
                            (("6" (expand "restrict")
                              (("6"
                                (rewrite "plus_commutative")
                                nil
                                nil))
                              nil))
                            nil))
                          nil)
                         ("7" (skosimp)
                          (("7" (copy -3)
                            (("7" (inst -1 "x!1" "y!1")
                              (("7" (flatten) nil nil)) nil))
                            nil))
                          nil)
                         ("8" (expand "associative?")
                          (("8" (skosimp)
                            (("8" (expand "restrict")
                              (("8"
                                (rewrite "times_associative")
                                nil
                                nil))
                              nil))
                            nil))
                          nil)
                         ("9" (expand "left_distributive?")
                          (("9" (skosimp)
                            (("9" (expand "restrict")
                              (("9"
                                (rewrite "left_distributive")
                                nil
                                nil))
                              nil))
                            nil))
                          nil)
                         ("10" (expand "right_distributive?")
                          (("10" (skosimp)
                            (("10" (expand "restrict")
                              (("10"
                                (rewrite "right_distributive")
                                nil
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ring? const-decl "bool" ring_def nil)
    (group? const-decl "bool" group_def nil)
    (monad? const-decl "bool" monad_def nil)
    (nonempty? const-decl "bool" sets nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (monoid? const-decl "bool" monoid_def nil)
    (abelian_group? const-decl "bool" group_def nil)
    (subring? const-decl "bool" ring_def nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (inv_is_member_R formula-decl nil ring_basic_properties nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (R_sum_star_closed formula-decl nil ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (R_prod_star_closed formula-decl nil ring_basic_properties nil)
    (star_closed? const-decl "bool" groupoid_def nil)
    (right_distributive? const-decl "bool" operator_defs_more nil)
    (right_distributive formula-decl nil ring nil)
    (left_distributive? const-decl "bool" operator_defs_more nil)
    (left_distributive formula-decl nil ring nil)
    (times_associative formula-decl nil ring nil)
    (commutative? const-decl "bool" operator_defs nil)
    (plus_commutative formula-decl nil ring nil)
    (inv_exists? const-decl "bool" group_def nil)
    (negate_is_left_inv formula-decl nil ring nil)
    (associative? const-decl "bool" operator_defs nil)
    (plus_associative formula-decl nil ring nil)
    (identity? const-decl "bool" operator_defs nil)
    (restrict const-decl "R" restrict nil)
    (zero_plus formula-decl nil ring nil)
    (plus_zero formula-decl nil ring nil)
    (negate_is_right_inv formula-decl nil ring nil)
    (negate_negate formula-decl nil ring nil)
    (left_identity formula-decl nil monad nil)
    (inv_right formula-decl nil group nil))
   nil)
  (subring_equiv-1 nil 3706983053
   ("" (skosimp)
    (("" (split)
      (("1" (flatten)
        (("1" (lemma "subgroup_def")
          (("1" (inst -1 "R!1" "S!1")
            (("1" (case "subgroup?(S!1, R!1)")
              (("1" (assert)
                (("1" (flatten)
                  (("1" (assert)
                    (("1" (skosimp)
                      (("1" (split)
                        (("1" (expand "inv_closed?")
                          (("1" (inst -5 "y!1")
                            (("1" (expand "member")
                              (("1"
                                (lemma "closed")
                                (("1"
                                  (inst -1 "S!1" "x!1" "inv(y!1)")
                                  (("1"
                                    (expand "member")
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "subring?")
                          (("2" (expand "ring?")
                            (("2" (flatten)
                              (("2"
                                (hide-all-but (-7 1))
                                (("2"
                                  (expand "star_closed?")
                                  (("2"
                                    (inst -1 "x!1" "y!1")
                                    (("2"
                                      (expand "member")
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide -1 2)
                (("2" (expand "subgroup?")
                  (("2" (expand "subring?")
                    (("2" (expand "ring?")
                      (("2" (expand "abelian_group?")
                        (("2" (flatten)
                          (("2" (hide-all-but (-1 -2 1))
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (lemma "subgroup_def")
          (("2" (inst -1 "R!1" "S!1")
            (("2" (assert)
              (("2" (expand "subring?") (("2" (postpone) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (times_member 0
  (times_member-1 nil 3708547978
   ("" (lemma "expt_member")
    (("" (skosimp)
      (("" (inst -1 "R!1" "x!1" "k!1")
        (("" (expand "times") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((times const-decl "T" ring_basic_properties nil)
    (member const-decl "bool" sets nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (ring? const-decl "bool" ring_def nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (expt_member formula-decl nil group nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil))
   shostak))
 (left_times 0
  (left_times-1 nil 3712676070
   ("" (skolem 1 ("_" "x!1" "y!1"))
    (("" (measure-induct+ "abs(k)" "k")
      (("" (expand "times")
        (("" (expand "^")
          (("" (lift-if)
            (("" (prop)
              (("1" (expand "power" 1)
                (("1" (lift-if)
                  (("1" (prop)
                    (("1" (assert) nil nil)
                     ("2" (case-replace "x!2=-1")
                      (("1" (hide -3)
                        (("1" (assert)
                          (("1" (rewrite "negative_times") nil nil))
                          nil))
                        nil)
                       ("2" (inst -2 "x!2+1")
                        (("2" (expand "abs")
                          (("2" (assert)
                            (("2" (lemma "negative_times")
                              (("2"
                                (inst -1 "x!1" "y!1")
                                (("2"
                                  (replace -1 3 rl)
                                  (("2"
                                    (lemma left_distributive)
                                    (("2"
                                      (inst?)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "power" 2)
                (("2" (lift-if)
                  (("2" (assert)
                    (("2" (prop)
                      (("2" (inst -1 "x!2 -1")
                        (("2" (expand "abs")
                          (("2" (assert)
                            (("2" (rewrite "left_distributive")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (measure_induction formula-decl nil measure_induction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (times const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (^ const-decl "T" group nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (power_0 formula-decl nil monoid nil)
    (right_identity formula-decl nil monad nil)
    (negative_times formula-decl nil ring nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (left_distributive formula-decl nil ring nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero_times formula-decl nil ring nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (power def-decl "T" monoid_def nil))
   nil))
 (right_times 0
  (right_times-2 nil 3712676242
   ("" (skolem 1 ("_" "x!1" "y!1"))
    (("" (measure-induct+ "abs(k)" "k")
      (("" (expand "times")
        (("" (expand "^")
          (("" (lift-if)
            (("" (prop)
              (("1" (case-replace "x!2 = -1")
                (("1" (hide -3)
                  (("1" (assert)
                    (("1" (rewrite "times_negative") nil nil)) nil))
                  nil)
                 ("2" (inst -2 "x!2+1")
                  (("2" (expand "abs")
                    (("2" (assert)
                      (("2" (expand "power" 2)
                        (("2" (rewrite "right_distributive")
                          (("2" (replace -2 2)
                            (("2" (rewrite "times_negative")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (case-replace "x!2 = 0")
                (("1" (expand "power" 2) (("1" (assert) nil nil)) nil)
                 ("2" (inst -1 "x!2-1")
                  (("2" (expand "abs")
                    (("2" (assert)
                      (("2" (expand "power" 3)
                        (("2" (rewrite "right_distributive")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((pred type-eq-decl nil defined_types nil)
    (well_founded? const-decl "bool" orders nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (measure_induction formula-decl nil measure_induction nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (< const-decl "bool" reals nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (times const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (^ const-decl "T" group nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (right_distributive formula-decl nil ring nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (power def-decl "T" monoid_def nil)
    (times_negative formula-decl nil ring nil)
    (power_1 formula-decl nil monoid nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (times_zero formula-decl nil ring nil))
   nil)
  (right_times-1 nil 3708596740
   ("" (skolem 1 ("_" "x!1" "y!1"))
    (("" (measure-induct+ "abs(k)" "k")
      (("" (expand "times")
        (("" (lift-if)
          (("" (prop)
            (("1" (case-replace "x!2 = -1")
              (("1" (hide -3)
                (("1" (expand "abs")
                  (("1" (assert)
                    (("1" (rewrite "times_negative") nil nil)) nil))
                  nil))
                nil)
               ("2" (inst -2 "x!2+1")
                (("2" (expand "abs")
                  (("2" (assert)
                    (("2" (expand "power" 2)
                      (("2" (rewrite "negate_plus")
                        (("2" (rewrite "negate_plus")
                          (("2" (rewrite "right_distributive")
                            (("2" (replace -2 2)
                              (("2"
                                (rewrite "times_negative")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (case-replace "x!2 = 0")
              (("1" (expand "power" 2) (("1" (assert) nil nil)) nil)
               ("2" (inst -1 "x!2-1")
                (("2" (expand "abs" -1)
                  (("2" (assert)
                    (("2" (expand "power" 3)
                      (("2" (rewrite "right_distributive")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (inv_times_neg 0
  (inv_times_neg-1 nil 3708982496
   ("" (skosimp)
    (("" (expand "times")
      (("" (expand "^")
        (("" (lift-if)
          (("" (prop)
            (("1" (assert)
              (("1" (rewrite "inv_power" :dir rl) nil nil)) nil)
             ("2" (lift-if)
              (("2" (prop)
                (("1" (lemma "inv_expt")
                  (("1" (inst -1 "x!1" "k!1")
                    (("1" (expand "^")
                      (("1" (assert)
                        (("1" (replace -1 1 rl)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (case-replace "k!1 = 0")
                  (("1" (expand "power") (("1" (assert) nil nil)) nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((times const-decl "T" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (inv_one formula-decl nil group nil)
    (power def-decl "T" monoid_def nil)
    (inv_expt formula-decl nil group nil)
    (inv_inv formula-decl nil group nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (inv_power formula-decl nil group nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (^ const-decl "T" group nil)
    (minus_int_is_int application-judgement "int" integers nil))
   nil))
 (inv_times_inv 0
  (inv_times_inv-1 nil 3708981396
   ("" (lemma "inv_expt")
    (("" (skosimp)
      (("" (inst -1 "x!1" "k!1")
        (("" (expand "times") (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((times const-decl "T" ring_basic_properties nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (inv_expt formula-decl nil group nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil))
   shostak))
 (times_inv_neg 0
  (times_inv_neg-1 nil 3708983884
   ("" (skosimp)
    (("" (rewrite "inv_times_neg")
      (("" (rewrite "inv_times_inv") nil nil)) nil))
    nil)
   ((inv_times_neg formula-decl nil ring_basic_properties nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (inv_times_inv formula-decl nil ring_basic_properties nil))
   shostak))
 (times_int_zero 0
  (times_int_zero-1 nil 3708601163
   ("" (lemma "one_expt")
    (("" (skosimp)
      (("" (inst -1 "k!1")
        (("" (expand "times") (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((times const-decl "T" ring_basic_properties nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (one_expt formula-decl nil group nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil))
   shostak))
 (times_int_one 0
  (times_int_one-1 nil 3714313402
   ("" (skosimp)
    (("" (expand "times") (("" (rewrite "expt_1") nil nil)) nil)) nil)
   ((times const-decl "T" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (expt_1 formula-decl nil group nil))
   shostak))
 (times_sum 0
  (times_sum-1 nil 3708600010
   ("" (lemma "expt_mult")
    (("" (skosimp)
      (("" (inst -1 "x!1" "z!1" "k!1")
        (("" (expand "times") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((times const-decl "T" ring_basic_properties nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (expt_mult formula-decl nil group nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil))
   shostak))
 (times_o 0
  (times_o-1 nil 3709147130
   ("" (lemma "expt_expt")
    (("" (expand "times")
      (("" (skosimp) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((times const-decl "T" ring_basic_properties nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (expt_expt formula-decl nil group nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil))
   shostak))
 (times_product 0
  (times_product-1 nil 3709148264
   ("" (skosimp)
    (("" (rewrite "left_times")
      (("" (rewrite "right_times") (("" (rewrite "times_o") nil nil))
        nil))
      nil))
    nil)
   ((left_times formula-decl nil ring_basic_properties nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (times const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (times_o formula-decl nil ring_basic_properties nil)
    (right_times formula-decl nil ring_basic_properties nil))
   shostak))
 (R_sigma_TCC1 0
  (R_sigma_TCC1-1 nil 3701277422 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (R_sigma subtype "(number_fields.-)(ring_basic_properties.high, 1)"
    "nat")))
 (R_sigma_TCC2 0
  (R_sigma_TCC2-1 nil 3701278375 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (R_sigma termination
    "ring_basic_properties.R_sigma(ring_basic_properties.low, (number_fields.-)(ring_basic_properties.high, 1), ring_basic_properties.F)"
    "nil")))
 (R_sigma_first 0
  (R_sigma_first-2 nil 3709151519
   ("" (induct "high")
    (("1" (skosimp)
      (("1" (expand "R_sigma") (("1" (assert) nil nil)) nil)) nil)
     ("2" (skosimp*)
      (("2" (inst -1 "F!1" "low!1")
        (("2" (case "j!1 + 1 = low!1")
          (("1" (replace -1 1)
            (("1" (hide -)
              (("1" (expand "R_sigma") (("1" (assert) nil nil)) nil))
              nil))
            nil)
           ("2" (assert)
            (("2" (expand "R_sigma" 2 2)
              (("2" (lift-if)
                (("2" (prop)
                  (("1" (hide -2)
                    (("1" (expand* "R_sigma" "R_sigma")
                      (("1" (assert) nil nil)) nil))
                    nil)
                   ("2" (rewrite "plus_associative" 2 :dir rl)
                    (("2" (replace -1 2 rl)
                      (("2" (expand "R_sigma" 2 1)
                        (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (plus_associative formula-decl nil ring nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (right_identity formula-decl nil monad nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil)
  (R_sigma_first-1 nil 3709151435 ("" (postpone) nil nil) nil shostak))
 (R_sigma_eq_k 0
  (R_sigma_eq_k-1 nil 3709151819
   ("" (induct "high")
    (("1" (skosimp)
      (("1" (expand "R_sigma")
        (("1" (lift-if)
          (("1" (prop)
            (("1" (assert) nil nil)
             ("2" (assert)
              (("2" (inst -1 "low!1") (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst -1 "F!1" "G!1" "low!1" "k!1")
        (("2" (prop)
          (("1" (expand "R_sigma" 1)
            (("1" (lift-if)
              (("1" (prop)
                (("1" (assert) nil nil)
                 ("2" (assert)
                  (("2" (inst -3 "low!1") (("2" (assert) nil nil))
                    nil))
                  nil)
                 ("3" (assert)
                  (("3" (inst -2 "1+j!1") (("3" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 2)
            (("2" (skosimp) (("2" (inst -1 "n!1") nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (subrange type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (R_sigma_eq 0
  (R_sigma_eq-1 nil 3702649294
   ("" (skosimp)
    (("" (lemma "R_sigma_eq_k")
      (("" (inst -1 "F!1" "G!1" "high!1" "low!1" "0")
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((R_sigma_eq_k formula-decl nil ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (R_sigma_eq2 0
  (R_sigma_eq2-1 nil 3702919670
   ("" (skosimp)
    (("" (lemma "R_sigma_eq_k")
      (("" (inst -1 "F!1" "G!1" "high!1" "low!1" "1")
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((R_sigma_eq_k formula-decl nil ring_basic_properties nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (R_sigma_sum 0
  (R_sigma_sum-1 nil 3702762176
   ("" (induct "high")
    (("1" (skosimp)
      (("1" (expand "R_sigma")
        (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst -1 "F!1" "G!1" "low!1")
        (("2" (expand "R_sigma" 1)
          (("2" (lift-if)
            (("2" (assert)
              (("2" (prop)
                (("2" (replace -1 2 rl)
                  (("2" (rewrite "plus_associative")
                    (("2" (rewrite "plus_associative" :dir rl)
                      (("2" (rewrite "plus_commutative")
                        (("2" (rewrite "plus_associative")
                          (("2" (rewrite "plus_associative") nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (plus_commutative formula-decl nil ring nil)
    (plus_associative formula-decl nil ring nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (left_identity formula-decl nil monad nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (ast_R_sigma 0
  (ast_R_sigma-1 nil 3701277439
   ("" (induct "high")
    (("1" (skeep)
      (("1" (expand* "R_sigma" "R_sigma")
        (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "R_sigma" 1)
        (("2" (lift-if)
          (("2" (prop)
            (("1" (assert) nil nil)
             ("2" (inst -1 "F!1" "low!1" "x!1")
              (("2" (rewrite "right_distributive")
                (("2" (replaces -1) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (right_distributive formula-decl nil ring nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (times_zero formula-decl nil ring nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (R_sigma_ast 0
  (R_sigma_ast-1 nil 3701278711
   ("" (induct "high")
    (("1" (skeep)
      (("1" (expand* "R_sigma" "R_sigma")
        (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil))
      nil)
     ("2" (skosimp*)
      (("2" (expand "R_sigma" 1)
        (("2" (lift-if)
          (("2" (prop)
            (("1" (assert) nil nil)
             ("2" (inst -1 "F!1" "low!1" "x!1")
              (("2" (rewrite "left_distributive")
                (("2" (replaces -1) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (left_distributive formula-decl nil ring nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (zero_times formula-decl nil ring nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (R_sigma_inv 0
  (R_sigma_inv-1 nil 3779035006
   ("" (induct "high")
    (("1" (skeep)
      (("1" (expand "R_sigma")
        (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil)) nil))
          nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand "R_sigma" 1)
          (("2" (lift-if)
            (("2" (prop)
              (("1" (assert) nil nil)
               ("2" (inst -1 "F" "low")
                (("2" (replace -1 2 rl)
                  (("2" (rewrite "negate_plus")
                    (("2" (rewrite "plus_commutative") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (plus_commutative formula-decl nil ring nil)
    (negate_plus formula-decl nil ring nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (inv_one formula-decl nil group nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (R_sigma_o 0
  (R_sigma_o-1 nil 3709158981
   ("" (induct "high")
    (("1" (skosimp)
      (("1" (expand "R_sigma" 1 (1 3))
        (("1" (assert)
          (("1" (lift-if)
            (("1" (prop)
              (("1" (assert) nil nil)
               ("2" (case-replace "low!1 = 0")
                (("1" (hide 1) (("1" (rewrite "ast_R_sigma") nil nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst -1 "F!1" "G!1" "high1!1" "low!1" "low1!1")
        (("2" (expand "R_sigma" 1 (1 3))
          (("2" (lift-if)
            (("2" (prop)
              (("1" (assert) nil nil)
               ("2" (hide -2) (("2" (rewrite "ast_R_sigma") nil nil))
                nil)
               ("3" (rewrite "left_distributive")
                (("3" (replace -1 2 rl)
                  (("3" (hide -1)
                    (("3" (rewrite "cancel_left_plus")
                      (("3" (rewrite "ast_R_sigma") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cancel_left_plus formula-decl nil ring nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (left_distributive formula-decl nil ring nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (zero_times formula-decl nil ring nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (ast_R_sigma formula-decl nil ring_basic_properties nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (R_sigma_R_sigma_TCC1 0
  (R_sigma_R_sigma_TCC1-1 nil 3778525032 ("" (subtype-tcc) nil nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (R_sigma_R_sigma subtype
    "(number_fields.+)((number_fields.+)(ring_basic_properties.high, ((number_fields.-)(ring_basic_properties.high1, ring_basic_properties.low1))), 1)"
    "nat")))
 (R_sigma_R_sigma_TCC2 0
  (R_sigma_R_sigma_TCC2-1 nil 3778525032 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (R_sigma_R_sigma subtype
    "(number_fields.-)((number_fields.+)((number_fields.-)(ring_basic_properties.i, ring_basic_properties.high), ring_basic_properties.low1), 1)"
    "nat")))
 (R_sigma_R_sigma 0
  (R_sigma_R_sigma-1 nil 3778525118
   ("" (measure-induct+ "high1 - low1 " ("low1" "high1"))
    (("1" (typepred "x!2")
      (("1" (case "x!2 = x!1")
        (("1" (replaces -1)
          (("1" (assert)
            (("1" (expand "R_sigma" 1 3)
              (("1" (expand "R_sigma" 1 2)
                (("1" (lemma " R_sigma_eq_k")
                  (("1" (skeep)
                    (("1"
                      (inst -1 "F" "LAMBDA (i: nat):
                       IF (i >= low AND i <= high) THEN F(i)
                       ELSIF (i > high AND i <= 1 + high)
                         THEN G(i - 1 - high + x!1)
                       ELSE zero
                       ENDIF" "high" "low" "0")
                      (("1" (assert) nil nil)
                       ("2" (skeep) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (expand "R_sigma" 2 2)
            (("2" (expand "R_sigma" 2 3)
              (("2" (inst -2 "x!1" "x!2 -1")
                (("1" (inst -2 "F" "G" "low" "high")
                  (("1" (assert)
                    (("1" (rewrite "plus_associative" :dir rl)
                      (("1" (replace -2 2)
                        (("1"
                          (case-replace " R_sigma(low, high - x!1 + x!2,
              LAMBDA (i: nat):
                IF (i >= low AND i <= high) THEN F(i)
                ELSIF (i > high AND i <= high - x!1 + x!2)
                  THEN G(i - 1 - high + x!1)
                ELSE zero
                ENDIF) = R_sigma(low, high - x!1 + x!2,
               LAMBDA (i: nat):
                 IF (i >= low AND i <= high) THEN F(i)
                 ELSIF (i > high AND i <= 1 - x!1 + high + x!2)
                   THEN G(i - 1 - high + x!1)
                 ELSE zero
                 ENDIF)")
                          (("1" (hide -2 3)
                            (("1" (rewrite "R_sigma_eq")
                              (("1"
                                (hide 2)
                                (("1"
                                  (skeep)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (hide 2)
                                (("2"
                                  (skeep)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (skeep) (("2" (assert) nil nil)) nil)
                           ("3" (skeep) (("3" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (typepred "x!1")
                  (("2" (hide 3) (("2" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep) (("2" (assert) nil nil)) nil)
     ("3" (skeep) (("3" (assert) nil nil)) nil)
     ("4" (skeep) (("4" (assert) nil nil)) nil)
     ("5" (skeep) (("5" (assert) nil nil)) nil)
     ("6" (skeep) (("6" (assert) nil nil)) nil)
     ("7" (skeep) (("7" (assert) nil nil)) nil)
     ("8" (skeep) (("8" (assert) nil nil)) nil)
     ("9" (skeep) (("9" (assert) nil nil)) nil)
     ("10" (skeep) (("10" (assert) nil nil)) nil)
     ("11" (skeep) (("11" (assert) nil nil)) nil)
     ("12" (skeep) (("12" (assert) nil nil)) nil))
    nil)
   ((* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (plus_associative formula-decl nil ring nil)
    (R_sigma_eq formula-decl nil ring_basic_properties nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (R_sigma_eq_k formula-decl nil ring_basic_properties nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (R_sigma_is_member_R 0
  (R_sigma_is_member_R-1 nil 3808732243
   ("" (induct "high")
    (("1" (skosimp)
      (("1" (expand "member")
        (("1" (expand "R_sigma")
          (("1" (prop)
            (("1" (lemma "zero_is_member_R")
              (("1" (inst -1 "R!1")
                (("1" (expand "member") (("1" (propax) nil nil)) nil))
                nil))
              nil)
             ("2" (inst -1 "low!1") (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skosimp)
      (("2" (skosimp)
        (("2" (case "R!1(zero)")
          (("1" (inst -2 "F!1" "R!1" "low!1")
            (("1" (prop)
              (("1" (copy -3)
                (("1" (case "low!1 >= j!1 + 1")
                  (("1" (hide-all-but (-1 1))
                    (("1" (expand "member")
                      (("1" (expand "R_sigma")
                        (("1" (expand ">=")
                          (("1" (expand "<=")
                            (("1" (split)
                              (("1"
                                (assert)
                                (("1"
                                  (lemma "zero_is_member_R")
                                  (("1"
                                    (inst -1 "R!1")
                                    (("1"
                                      (expand "member")
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (assert)
                                (("2"
                                  (reveal -3)
                                  (("2"
                                    (inst -1 "low!1")
                                    (("2"
                                      (expand "member")
                                      (("2" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (inst -1 "1+j!1")
                    (("1"
                      (case "R_sigma(low!1, j!1 + 1, F!1) = R_sigma(low!1, j!1, F!1) + F!1(1 + j!1)")
                      (("1" (lemma R_sum_star_closed)
                        (("1"
                          (inst -1 "R!1" "R_sigma(low!1, j!1, F!1)"
                           "F!1(1 + j!1)")
                          (("1" (replace -2 -1 rl)
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (hide-all-but 1)
                        (("2" (expand "R_sigma" 1 1)
                          (("2" (reveal 1) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (skosimp) (("2" (inst -2 "n!1") nil nil)) nil))
              nil))
            nil)
           ("2" (lemma "zero_is_member_R")
            (("2" (inst -1 "R!1")
              (("2" (expand "member") (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (R_sum_star_closed formula-decl nil ring_basic_properties nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (zero_is_member_R formula-decl nil ring_basic_properties nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (R_sigma def-decl "T" ring_basic_properties nil)
    (member const-decl "bool" sets nil)
    (subrange type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (ring? const-decl "bool" ring_def nil)
    (zero formal-const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (set type-eq-decl nil sets nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (nlzd_TCC1 0
  (nlzd_TCC1-1 nil 3720274509 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (nlzd subtype "ring_basic_properties.x" "nz_T[T, +, *, zero]")))
 (nzd_cancel_left 0
  (nzd_cancel_left-1 nil 3711987483
   ("" (skosimp)
    (("" (lemma "negate_is_right_inv")
      (("" (inst -1 "a!1 * c!1")
        (("" (rewrite "times_negative" :dir rl)
          (("" (replace -2 -1 rl)
            (("" (rewrite "right_distributive" :dir rl)
              (("" (hide -2)
                (("" (typepred "a!1")
                  (("" (assert)
                    (("" (expand "left_zd?")
                      (("" (inst 1 "b!1 + inv(c!1)")
                        (("" (flatten)
                          (("" (lemma "cancel_right_plus")
                            ((""
                              (inst -1 "b!1 + inv[T, +, zero](c!1)"
                               "zero" "c!1")
                              ((""
                                (assert)
                                ((""
                                  (hide -2 -3)
                                  ((""
                                    (rewrite "plus_associative")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((zero formal-const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (negate_is_right_inv formula-decl nil ring nil)
    (times_negative formula-decl nil ring nil)
    (right_distributive formula-decl nil ring nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (plus_associative formula-decl nil ring nil)
    (inv_left formula-decl nil group nil)
    (right_identity formula-decl nil monad nil)
    (left_identity formula-decl nil monad nil)
    (cancel_right_plus formula-decl nil ring nil)
    (nlzd type-eq-decl nil ring_basic_properties nil)
    (left_zd? const-decl "bool" ring_basic_properties nil)
    (nz_T type-eq-decl nil ring_nz_closed_def nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (nzd_cancel_right 0
  (nzd_cancel_right-1 nil 3719346921
   ("" (skosimp)
    (("" (lemma "negate_is_right_inv")
      (("" (inst -1 "c!1 * a!1")
        (("" (rewrite "negative_times" :dir rl)
          (("" (replace -2 -1 rl)
            (("" (rewrite "left_distributive" :dir rl)
              (("" (hide -2)
                (("" (typepred "a!1")
                  (("" (assert)
                    (("" (expand "right_zd?")
                      (("" (inst 1 "b!1 + inv(c!1)")
                        (("" (flatten)
                          (("" (lemma "cancel_right_plus")
                            ((""
                              (inst -1 "b!1 + inv[T, +, zero](c!1)"
                               "zero" "c!1")
                              ((""
                                (assert)
                                ((""
                                  (hide -2 -3)
                                  ((""
                                    (rewrite "plus_associative")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((zero formal-const-decl "T" ring_basic_properties nil)
    (* formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (+ formal-const-decl "[T, T -> T]" ring_basic_properties nil)
    (T formal-nonempty-type-decl nil ring_basic_properties nil)
    (negate_is_right_inv formula-decl nil ring nil)
    (negative_times formula-decl nil ring nil)
    (left_distributive formula-decl nil ring nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (plus_associative formula-decl nil ring nil)
    (inv_left formula-decl nil group nil)
    (right_identity formula-decl nil monad nil)
    (left_identity formula-decl nil monad nil)
    (cancel_right_plus formula-decl nil ring nil)
    (nrzd type-eq-decl nil ring_basic_properties nil)
    (right_zd? const-decl "bool" ring_basic_properties nil)
    (nz_T type-eq-decl nil ring_nz_closed_def nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak)))

