(ring_euclidean_gcd_algorithm_Z
 (Z_TCC1 0
  (Z_TCC1-1 nil 3860852971
   ("" (lemma "integers_is_euclidean_domain") (("" (propax) nil nil))
    nil)
   ((integers_is_euclidean_domain formula-decl nil euclidean_domain
     nil))
   nil
   (Z subtype "sets[int].fullset"
    "(euclidean_domain_def[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0, 1].euclidean_domain?)")))
 (f_phi_Z_TCC1 0
  (f_phi_Z_TCC1-1 nil 3860852971 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (/= const-decl "boolean" notequal nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil (f_phi_Z subtype "ring_euclidean_gcd_algorithm_Z.j" "posnat")))
 (f_phi_Z_TCC2 0
  (f_phi_Z_TCC2-1 nil 3860852971 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (/= const-decl "boolean" notequal nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (f_phi_Z subtype
    "(number_fields.-)(ring_euclidean_gcd_algorithm_Z.j)" "posnat")))
 (phi_Z_and_f_phi_Z_ok_TCC1 0
  (phi_Z_and_f_phi_Z_ok_TCC1-1 nil 3860852971
   ("" (subtype-tcc) nil nil)
   ((remove const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nzint_abs_is_pos application-judgement "{j: posint | j >= i}"
     real_defs nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (fullset const-decl "set" sets nil)
    (f_phi_Z const-decl "[int, below[abs(j)]]"
     ring_euclidean_gcd_algorithm_Z nil)
    (Z const-decl "(euclidean_domain?
     [int, restrict[[numfield, numfield], [int, int], numfield](+),
      restrict[[numfield, numfield], [int, int], numfield](*), 0, 1])"
     ring_euclidean_gcd_algorithm_Z nil))
   nil
   (phi_Z_and_f_phi_Z_ok subtype
    "ring_euclidean_gcd_algorithm_Z.f_phi_Z"
    "[[(ring_euclidean_gcd_algorithm_Z.Z), (sets[int].remove(0, ring_euclidean_gcd_algorithm_Z.Z))] -> [(ring_euclidean_gcd_algorithm_Z.Z), (ring_euclidean_gcd_algorithm_Z.Z)]]")))
 (phi_Z_and_f_phi_Z_ok_TCC2 0
  (phi_Z_and_f_phi_Z_ok_TCC2-1 nil 3860852971
   ("" (prop)
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (expand "euclidean_pair?")
      (("2" (skeep)
        (("2" (prop)
          (("1" (expand "phi_Z")
            (("1" (use "abs_mult")
              (("1" (replaces)
                (("1" (case "abs(a) >= 1 AND abs(b) >= 1")
                  (("1" (prop)
                    (("1" (lemma "both_sides_times_pos_le2")
                      (("1" (inst -1 "abs(a)" "1" "abs(b)")
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 3) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (inst 2 "f_phi_Z(a,b)`1" "f_phi_Z(a,b)`2")
            (("1" (expand "f_phi_Z")
              (("1" (case "rem(abs(b))(a) = 0")
                (("1" (replace -1 2)
                  (("1" (assert)
                    (("1" (lift-if)
                      (("1" (prop)
                        (("1" (typepred "ndiv(a, b)")
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil)
                         ("2" (typepred "ndiv(a, -b)")
                          (("1" (expand "abs") (("1" (assert) nil nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (lift-if)
                  (("2" (prop)
                    (("1" (expand "abs")
                      (("1" (lift-if)
                        (("1" (prop)
                          (("1" (assert) nil nil)
                           ("2" (typepred "ndiv(a,b)")
                            (("1" (use "commutative_mult")
                              (("1" (replaces -1) nil nil)
                               ("2"
                                (hide-all-but (-2 1))
                                (("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide 3 4)
                      (("2" (expand "abs")
                        (("2" (assert)
                          (("2" (typepred "rem(b)(a)")
                            (("2" (expand "phi_Z")
                              (("2"
                                (expand "abs")
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (expand "abs")
                      (("3" (lift-if)
                        (("3" (prop)
                          (("1" (typepred "ndiv(a, -b)")
                            (("1" (use "neg_mult")
                              (("1" (replaces -1) nil nil)
                               ("2" (assert) nil nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("4" (hide 4)
                      (("4" (expand "abs")
                        (("4" (lift-if)
                          (("4" (prop)
                            (("1" (hide -2)
                              (("1"
                                (typepred "rem(-b)(a)")
                                (("1"
                                  (expand "phi_Z")
                                  (("1"
                                    (expand "abs")
                                    (("1"
                                      (lift-if)
                                      (("1"
                                        (prop)
                                        (("1"
                                          (lift-if)
                                          (("1"
                                            (prop)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (lift-if)
                                          (("2" (prop) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (hide 3) (("3" (assert) nil nil)) nil))
                nil))
              nil)
             ("2" (grind) nil nil) ("3" (grind) nil nil)
             ("4" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_times_int_is_int application-judgement "int" integers nil)
    (euclidean_pair? const-decl "bool" euclidean_ring_def nil)
    (abs_mult formula-decl nil real_props nil)
    (euclidean_domain? const-decl "bool" euclidean_domain_def nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (restrict const-decl "R" restrict nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (both_sides_times_pos_le2 formula-decl nil real_props nil)
    (abs_nat_rew formula-decl nil abs_rews ints)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (phi_Z const-decl "posnat" ring_euclidean_gcd_algorithm_Z nil)
    (neg_mult formula-decl nil extra_tegies nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (commutative_mult formula-decl nil number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (ndiv const-decl "{q: int | x = b * q + rem(b)(x)}"
     modulo_arithmetic nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (f_phi_Z const-decl "[int, below[abs(j)]]"
     ring_euclidean_gcd_algorithm_Z nil)
    (difference const-decl "set" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (fullset const-decl "set" sets nil)
    (Z const-decl "(euclidean_domain?
     [int, restrict[[numfield, numfield], [int, int], numfield](+),
      restrict[[numfield, numfield], [int, int], numfield](*), 0, 1])"
     ring_euclidean_gcd_algorithm_Z nil)
    (/= const-decl "boolean" notequal nil))
   nil
   (phi_Z_and_f_phi_Z_ok subtype "ring_euclidean_gcd_algorithm_Z.phi_Z"
    "{phi: [(sets[int].difference(ring_euclidean_gcd_algorithm_Z.Z, sets[int].singleton(0))) -> naturalnumbers.nat] | euclidean_ring_def[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].euclidean_pair?(ring_euclidean_gcd_algorithm_Z.Z, phi)}")))
 (phi_Z_and_f_phi_Z_ok 0
  (phi_Z_and_f_phi_Z_ok-1 nil 3860852985
   ("" (expand "euclidean_f_phi?")
    (("" (skeep)
      (("" (prop)
        (("1" (replaces)
          (("1" (expand "f_phi_Z")
            (("1" (prop)
              (("1" (lift-if)
                (("1" (prop)
                  (("1" (lemma "modulo_arithmetic.rem_zero")
                    (("1" (inst?)
                      (("1" (typepred "ndiv(0, b)")
                        (("1" (replaces -3) (("1" (assert) nil nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil)
                   ("2" (typepred "ndiv(0, -b)")
                    (("1" (lemma "modulo_arithmetic.rem_zero")
                      (("1" (inst?)
                        (("1" (replaces -1) (("1" (assert) nil nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (lemma "modulo_arithmetic.rem_zero")
                (("2" (inst?) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (expand "f_phi_Z")
          (("2" (lift-if)
            (("2" (prop)
              (("1" (expand "abs")
                (("1" (lift-if)
                  (("1" (prop)
                    (("1" (assert) nil nil)
                     ("2" (typepred "ndiv(a,b)")
                      (("1" (use "commutative_add")
                        (("1" (replaces -1) nil nil)
                         ("2" (hide-all-but (-2 1))
                          (("2" (assert) nil nil)) nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "abs")
                (("2" (assert)
                  (("2" (lift-if)
                    (("2" (prop)
                      (("1" (typepred "ndiv(a, -b)")
                        (("1" (use "commutative_add")
                          (("1" (replaces -1) nil nil)) nil))
                        nil)
                       ("2" (hide 2)
                        (("2" (typepred "b")
                          (("2" (expand "remove")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (expand "phi_Z")
          (("3" (expand "f_phi_Z")
            (("3" (typepred "rem(abs(b))(a)")
              (("3" (expand "abs")
                (("3" (lift-if)
                  (("3" (lift-if)
                    (("3" (lift-if)
                      (("3" (prop)
                        (("1" (hide-all-but -2) (("1" (grind) nil nil))
                          nil)
                         ("2" (hide-all-but -1) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((phi_Z const-decl "posnat" ring_euclidean_gcd_algorithm_Z nil)
    (commutative_add formula-decl nil number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member const-decl "bool" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Z const-decl "(euclidean_domain?
     [int, restrict[[numfield, numfield], [int, int], numfield](+),
      restrict[[numfield, numfield], [int, int], numfield](*), 0, 1])"
     ring_euclidean_gcd_algorithm_Z nil)
    (euclidean_domain? const-decl "bool" euclidean_domain_def nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (restrict const-decl "R" restrict nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (remove const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil)
    (ndiv const-decl "{q: int | x = b * q + rem(b)(x)}"
     modulo_arithmetic nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nil application-judgement "upto(n)" modulo_arithmetic nil)
    (rem_zero formula-decl nil modulo_arithmetic nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (f_phi_Z const-decl "[int, below[abs(j)]]"
     ring_euclidean_gcd_algorithm_Z nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (euclidean_f_phi? const-decl "bool" euclidean_ring_def nil)
    (int_times_int_is_int application-judgement "int" integers nil))
   shostak))
 (euclidean_gcd_alg_correctness_in_Z_TCC1 0
  (euclidean_gcd_alg_correctness_in_Z_TCC1-1 nil 3860852971
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (Z const-decl "(euclidean_domain?
     [int, restrict[[numfield, numfield], [int, int], numfield](+),
      restrict[[numfield, numfield], [int, int], numfield](*), 0, 1])"
     ring_euclidean_gcd_algorithm_Z nil)
    (fullset const-decl "set" sets nil)
    (extend const-decl "R" extend nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil))
   nil
   (euclidean_gcd_alg_correctness_in_Z subtype
    "extend[int, (ring_euclidean_gcd_algorithm_Z.Z), booleans.bool, booleans.FALSE].extend({x: (ring_euclidean_gcd_algorithm_Z.Z) | booleans.OR(x = ring_euclidean_gcd_algorithm_Z.i, x = ring_euclidean_gcd_algorithm_Z.j)})"
    "{X | booleans.AND((booleans.NOT)(sets[int].empty?(X)), sets[int].subset?(X, ring_euclidean_gcd_algorithm_Z.Z))}")))
 (euclidean_gcd_alg_correctness_in_Z_TCC2 0
  (euclidean_gcd_alg_correctness_in_Z_TCC2-1 nil 3860852971
   ("" (subtype-tcc) nil nil)
   ((Z const-decl "(euclidean_domain?
     [int, restrict[[numfield, numfield], [int, int], numfield](+),
      restrict[[numfield, numfield], [int, int], numfield](*), 0, 1])"
     ring_euclidean_gcd_algorithm_Z nil)
    (fullset const-decl "set" sets nil))
   nil
   (euclidean_gcd_alg_correctness_in_Z subtype
    "ring_euclidean_gcd_algorithm_Z.i"
    "(ring_euclidean_gcd_algorithm_Z.Z)")))
 (euclidean_gcd_alg_correctness_in_Z_TCC3 0
  (euclidean_gcd_alg_correctness_in_Z_TCC3-1 nil 3860852971
   ("" (subtype-tcc) nil nil)
   ((Z const-decl "(euclidean_domain?
     [int, restrict[[numfield, numfield], [int, int], numfield](+),
      restrict[[numfield, numfield], [int, int], numfield](*), 0, 1])"
     ring_euclidean_gcd_algorithm_Z nil)
    (fullset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (remove const-decl "set" sets nil))
   nil
   (euclidean_gcd_alg_correctness_in_Z subtype
    "ring_euclidean_gcd_algorithm_Z.j"
    "(sets[int].remove(0, ring_euclidean_gcd_algorithm_Z.Z))")))
 (euclidean_gcd_alg_correctness_in_Z_TCC4 0
  (euclidean_gcd_alg_correctness_in_Z_TCC4-1 nil 3860852971
   ("" (lemma "phi_Z_and_f_phi_Z_ok")
    (("" (skeep)
      (("" (prop)
        (("1" (hide -) (("1" (grind) nil nil)) nil)
         ("2" (hide -) (("2" (grind) nil nil)) nil)
         ("3" (hide -) (("3" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (f_phi_Z const-decl "[int, below[abs(j)]]"
     ring_euclidean_gcd_algorithm_Z nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (nzint_abs_is_pos application-judgement "{j: posint | j >= i}"
     real_defs nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (member const-decl "bool" sets nil)
    (remove const-decl "set" sets nil)
    (Z const-decl "(euclidean_domain?
     [int, restrict[[numfield, numfield], [int, int], numfield](+),
      restrict[[numfield, numfield], [int, int], numfield](*), 0, 1])"
     ring_euclidean_gcd_algorithm_Z nil)
    (fullset const-decl "set" sets nil)
    (phi_Z_and_f_phi_Z_ok formula-decl nil
     ring_euclidean_gcd_algorithm_Z nil))
   nil
   (euclidean_gcd_alg_correctness_in_Z subtype
    "ring_euclidean_gcd_algorithm_Z.f_phi_Z"
    "{f_phi: [(ring_euclidean_gcd_algorithm_Z.Z), (sets[int].remove(0, ring_euclidean_gcd_algorithm_Z.Z)) -> [(ring_euclidean_gcd_algorithm_Z.Z), (ring_euclidean_gcd_algorithm_Z.Z)]] | euclidean_ring_def[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0].euclidean_f_phi?(ring_euclidean_gcd_algorithm_Z.Z, ring_euclidean_gcd_algorithm_Z.phi_Z)(f_phi)}")))
 (euclidean_gcd_alg_correctness_in_Z_TCC5 0
  (euclidean_gcd_alg_correctness_in_Z_TCC5-1 nil 3860852971
   ("" (skeep)
    (("" (expand "ring_with_one?")
      (("" (lemma "integers_is_euclidean_domain")
        (("" (expand "euclidean_domain?")
          (("" (expand "euclidean_ring?")
            (("" (flatten)
              (("" (hide -2 -3)
                (("" (expand "commutative_ring?")
                  (("" (flatten)
                    (("" (prop)
                      (("" (hide -)
                        (("" (expand "monoid?")
                          (("" (expand "monad?")
                            (("" (split)
                              (("1"
                                (expand "star_closed?")
                                (("1"
                                  (skeep)
                                  (("1"
                                    (expand "member")
                                    (("1"
                                      (expand "fullset")
                                      (("1" (propax) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (expand "member")
                                (("2"
                                  (expand "fullset")
                                  (("2" (propax) nil nil))
                                  nil))
                                nil)
                               ("3"
                                (expand "identity?")
                                (("3"
                                  (skeep)
                                  (("3"
                                    (expand "restrict")
                                    (("3" (propax) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("4"
                                (expand "associative?")
                                (("4"
                                  (skeep)
                                  (("4"
                                    (expand "restrict")
                                    (("4"
                                      (lemma "associative[int,*]")
                                      (("4" (inst?) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ring_with_one? const-decl "bool" ring_with_one_def nil)
    (euclidean_domain? const-decl "bool" euclidean_domain_def nil)
    (commutative_ring? const-decl "bool" ring_def nil)
    (monoid? const-decl "bool" monoid_def nil)
    (fullset const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (star_closed? const-decl "bool" groupoid_def nil)
    (restrict const-decl "R" restrict nil)
    (identity? const-decl "bool" operator_defs nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (associative formula-decl nil semigroup nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (associative? const-decl "bool" operator_defs nil)
    (monad? const-decl "bool" monad_def nil)
    (euclidean_ring? const-decl "bool" euclidean_ring_def nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (integers_is_euclidean_domain formula-decl nil euclidean_domain
     nil))
   nil
   (euclidean_gcd_alg_correctness_in_Z assuming
    "ring_euclidean_algorithm[int, restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.+), restrict[[numfield, numfield], [int, int], numfield].restrict(number_fields.*), 0, 1].ring_euclidean_algorithm"
    "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_euclidean_algorithm.T, ring_euclidean_algorithm.+, ring_euclidean_algorithm.*, ring_euclidean_algorithm.zero, ring_euclidean_algorithm.one].ring_with_one?(sets[ring_euclidean_algorithm.T].fullset)")))
 (euclidean_gcd_alg_correctness_in_Z 0
  (euclidean_gcd_alg_correctness_in_Z-1 nil 3860853095
   ("" (skeep)
    (("" (lemma "euclidean_gcd_alg_correctness[int,+,*,0,1]")
      (("" (inst?) nil nil)) nil))
    nil)
   ((* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (restrict const-decl "R" restrict nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (euclidean_gcd_alg_correctness formula-decl nil
     ring_euclidean_algorithm nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (euclidean_domain? const-decl "bool" euclidean_domain_def nil)
    (Z const-decl "(euclidean_domain?
     [int, restrict[[numfield, numfield], [int, int], numfield](+),
      restrict[[numfield, numfield], [int, int], numfield](*), 0, 1])"
     ring_euclidean_gcd_algorithm_Z nil)
    (difference const-decl "set" sets nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (euclidean_ring? const-decl "bool" euclidean_ring_def nil)
    (euclidean_pair? const-decl "bool" euclidean_ring_def nil)
    (/= const-decl "boolean" notequal nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (phi_Z const-decl "posnat" ring_euclidean_gcd_algorithm_Z nil)
    (remove const-decl "set" sets nil)
    (euclidean_f_phi? const-decl "bool" euclidean_ring_def nil)
    (< const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (below type-eq-decl nil nat_types nil)
    (f_phi_Z const-decl "[int, below[abs(j)]]"
     ring_euclidean_gcd_algorithm_Z nil))
   shostak)))