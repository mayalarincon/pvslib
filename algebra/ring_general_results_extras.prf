(ring_general_results_extras
 (IMP_ring_homomorphism_lemmas_TCC1 0
  (IMP_ring_homomorphism_lemmas_TCC1-1 nil 3801936839
   ("" (lemma "R1_is_ring_with_one")
    (("" (expand "ring_with_one?") (("" (assert) nil nil)) nil)) nil)
   (nil
    (R1_is_ring_with_one formula-decl nil ring_general_results_extras
     nil))
   nil
   (IMP_ring_homomorphism_lemmas assuming
    "ring_homomorphism_lemmas[ring_general_results_extras.T1, ring_general_results_extras.s1, ring_general_results_extras.p1, ring_general_results_extras.zero1, ring_general_results_extras.T2, ring_general_results_extras.s2, ring_general_results_extras.p2, ring_general_results_extras.zero2].ring_homomorphism_lemmas"
    "R1_is_ring: ASSUMPTION ring_def[ring_homomorphism_lemmas.T1, ring_homomorphism_lemmas.s1, ring_homomorphism_lemmas.p1, ring_homomorphism_lemmas.zero1].ring?(sets[ring_homomorphism_lemmas.T1].fullset)")))
 (IMP_ring_homomorphism_lemmas_TCC2 0
  (IMP_ring_homomorphism_lemmas_TCC2-1 nil 3801936839
   ("" (rewrite "R2_is_ring") nil nil)
   ((R2_is_ring formula-decl nil ring_general_results_extras nil)) nil
   (IMP_ring_homomorphism_lemmas assuming
    "ring_homomorphism_lemmas[ring_general_results_extras.T1, ring_general_results_extras.s1, ring_general_results_extras.p1, ring_general_results_extras.zero1, ring_general_results_extras.T2, ring_general_results_extras.s2, ring_general_results_extras.p2, ring_general_results_extras.zero2].ring_homomorphism_lemmas"
    "R2_is_ring: ASSUMPTION ring_def[ring_homomorphism_lemmas.T2, ring_homomorphism_lemmas.s2, ring_homomorphism_lemmas.p2, ring_homomorphism_lemmas.zero2].ring?(sets[ring_homomorphism_lemmas.T2].fullset)")))
 (IMP_ring_general_results_TCC1 0
  (IMP_ring_general_results_TCC1-1 nil 3801936839
   ("" (rewrite "R1_is_ring_with_one") nil nil)
   ((R1_is_ring_with_one formula-decl nil ring_general_results_extras
     nil))
   nil
   (IMP_ring_general_results assuming
    "ring_general_results[ring_general_results_extras.T1, ring_general_results_extras.s1, ring_general_results_extras.p1, ring_general_results_extras.zero1, ring_general_results_extras.one1].ring_general_results"
    "fullset_is_ring_with_one: ASSUMPTION ring_with_one_def[ring_general_results.T, ring_general_results.+, ring_general_results.*, ring_general_results.zero, ring_general_results.one].ring_with_one?(sets[ring_general_results.T].fullset)")))
 (no_prop_id_mono_TCC1 0
  (no_prop_id_mono_TCC1-1 nil 3782476569
   ("" (skeep)
    (("" (inst 1 "I!1") (("" (rewrite "ideal_is_coset") nil nil)) nil))
    nil)
   ((T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (coset? const-decl "bool" cosets_def nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (zero1 formal-const-decl "T1" ring_general_results_extras nil)
    (one1 formal-const-decl "T1" ring_general_results_extras nil) nil
    nil nil (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (coset type-eq-decl nil cosets_def nil) nil nil
    (ideal_is_coset formula-decl nil ring_cosets_lemmas nil) nil)
   nil
   (no_prop_id_mono existence ""
    "cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I)")))
 (no_prop_id_mono_TCC2 0
  (no_prop_id_mono_TCC2-1 nil 3782476569
   ("" (skeep*)
    (("" (lemma "coset_add")
      (("" (inst?)
        (("" (inst -1 "x1`1" "x1`2") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((zero1 formal-const-decl "T1" ring_general_results_extras nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (coset_add formula-decl nil quotient_rings nil)
    (coset type-eq-decl nil cosets_def nil)
    (coset? const-decl "bool" cosets_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil) nil nil
    (one1 formal-const-decl "T1" ring_general_results_extras nil) nil
    nil (set type-eq-decl nil sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (no_prop_id_mono subtype
    "cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].add(ring_general_results_extras.R, ring_general_results_extras.I)"
    "[[cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I), cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I)] -> cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I)]")))
 (no_prop_id_mono_TCC3 0
  (no_prop_id_mono_TCC3-1 nil 3782476569
   ("" (skeep*)
    (("" (lemma "coset_product")
      (("" (inst?)
        (("" (inst -1 "x1`1" "x1`2") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((zero1 formal-const-decl "T1" ring_general_results_extras nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (coset_product formula-decl nil quotient_rings nil)
    (coset type-eq-decl nil cosets_def nil)
    (coset? const-decl "bool" cosets_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil) nil nil
    (one1 formal-const-decl "T1" ring_general_results_extras nil) nil
    nil (set type-eq-decl nil sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (no_prop_id_mono subtype
    "product_coset_def[ring_general_results_extras.T1, ring_general_results_extras.s1, ring_general_results_extras.p1].product(ring_general_results_extras.R, ring_general_results_extras.I)"
    "[[cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I), cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I)] -> cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I)]")))
 (no_prop_id_mono_TCC4 0
  (no_prop_id_mono_TCC4-1 nil 3782476569
   ("" (skeep) (("" (rewrite "ideal_is_coset") nil nil)) nil)
   ((ideal_is_coset formula-decl nil ring_cosets_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil) nil nil
    (one1 formal-const-decl "T1" ring_general_results_extras nil) nil
    nil (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (zero1 formal-const-decl "T1" ring_general_results_extras nil))
   nil
   (no_prop_id_mono subtype "ring_general_results_extras.I"
    "cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I)")))
 (no_prop_id_mono_TCC5 0
  (no_prop_id_mono_TCC5-1 nil 3782476569
   ("" (skeep*) (("" (rewrite "fullset_quot_group_is_ring") nil nil))
    nil)
   ((fullset_quot_group_is_ring formula-decl nil quotient_rings nil)
    (set type-eq-decl nil sets nil) nil nil
    (one1 formal-const-decl "T1" ring_general_results_extras nil) nil
    nil (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (zero1 formal-const-decl "T1" ring_general_results_extras nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (no_prop_id_mono assuming
    "ring[cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].coset(ring_general_results_extras.R, ring_general_results_extras.I), cosets_def[ring_general_results_extras.T1, ring_general_results_extras.s1].add(ring_general_results_extras.R, ring_general_results_extras.I), product_coset_def[ring_general_results_extras.T1, ring_general_results_extras.s1, ring_general_results_extras.p1].product(ring_general_results_extras.R, ring_general_results_extras.I), ring_general_results_extras.I].ring"
    "fullset_is_ring: ASSUMPTION ring_def[ring.T, ring.+, ring.*, ring.zero].ring?(sets[ring.T].fullset)")))
 (no_prop_id_mono 0
  (no_prop_id_mono-1 nil 3782476585
   ("" (skeep)
    (("" (inst -1 "/[T1,s1](R,I!1)" "LAMBDA (r:(R)): +[T1,s1](r,I!1)")
      (("1" (prop)
        (("1" (lemma "ring_natural_homo")
          (("1" (inst -1 "R" "I!1")
            (("1" (assert)
              (("1" (flatten)
                (("1"
                  (lemma
                   "monomorphism_charac[T1,s1,p1,zero1,coset[T1,s1](R,I!1),add[T1,s1](R,I!1),product(R,I!1),I!1]")
                  (("1"
                    (inst -1 "R" "/[T1,s1](R,I!1)"
                     "LAMBDA (r: (R)): (+[T1, s1])(r, I!1)")
                    (("1" (assert) nil nil)
                     ("2" (hide-all-but (-3 1)) (("2" (grind) nil nil))
                      nil)
                     ("3" (skeep)
                      (("3" (expand "restrict")
                        (("3" (expand "/")
                          (("3" (hide-all-but 1)
                            (("3"
                              (case "coset?[T1, s1](R, I!1)(((+[T1, s1])(r, I!1)))")
                              (("1" (assert) nil nil)
                               ("2"
                                (hide 2)
                                (("2"
                                  (rewrite "lcoset_iff_coset" :dir rl)
                                  (("2"
                                    (expand "left_coset?")
                                    (("2" (inst 1 "r") nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("4" (hide-all-but 1)
                      (("4" (rewrite "quotient_group_is_ring") nil
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1)
                    (("2" (rewrite "fullset_quot_group_is_ring") nil
                      nil))
                    nil)
                   ("3" (hide-all-but 1)
                    (("3" (rewrite "R1_is_ring") nil nil)) nil)
                   ("4" (hide-all-but 1)
                    (("4" (rewrite "ideal_is_coset") nil nil)) nil)
                   ("5" (skeep)
                    (("5" (hide-all-but 1)
                      (("5" (lemma "coset_product")
                        (("5" (inst -1 "R" "I!1" "x1`1" "x1`2 ")
                          (("5" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("6" (skeep)
                    (("6" (hide-all-but 1)
                      (("6" (lemma "coset_add")
                        (("6" (inst -1 "R" "I!1" "x1`1" "x1`2")
                          (("6" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("7" (inst 1 "I!1")
                    (("7" (rewrite "ideal_is_coset") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "zero_homomorphism?")
          (("2" (inst -1 "one1")
            (("1" (lemma "one_diff_zero_coset")
              (("1" (inst -1 "R" "I!1") (("1" (assert) nil nil)) nil))
              nil)
             ("2" (hide-all-but 1)
              (("2" (typepred "R")
                (("2" (expand "ring_with_one?")
                  (("2" (expand "monoid?")
                    (("2" (expand "monad?")
                      (("2" (expand "member") (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "ring_natural_homo")
        (("2" (inst -1 "R" "I!1")
          (("2" (assert)
            (("2" (flatten)
              (("2" (hide-all-but (-1 1))
                (("2" (expand "R_epimorphism?")
                  (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (hide-all-but 1)
        (("3" (skeep)
          (("3" (expand "restrict")
            (("3" (expand "/")
              (("3"
                (case "coset?[T1, s1](R, I!1)(((+[T1, s1])(r, I!1)))")
                (("1" (assert) nil nil)
                 ("2" (hide 2)
                  (("2" (rewrite "lcoset_iff_coset" :dir rl)
                    (("2" (expand "left_coset?")
                      (("2" (inst 1 "r") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (hide-all-but 1)
        (("4" (rewrite "quotient_group_is_ring") nil nil)) nil))
      nil))
    nil)
   ((/ const-decl "setof[set[T]]" cosets_def nil)
    (setof type-eq-decl nil defined_types nil)
    (restrict const-decl "R" restrict nil)
    (product const-decl "set[T]" product_coset_def nil)
    (add const-decl "set[T]" cosets_def nil)
    (coset type-eq-decl nil cosets_def nil) nil
    (ideal type-eq-decl nil ring_ideal_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil) nil nil nil nil
    (one1 formal-const-decl "T1" ring_general_results_extras nil)
    (zero1 formal-const-decl "T1" ring_general_results_extras nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (coset? const-decl "bool" cosets_def nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    nil (AND const-decl "[bool, bool -> bool]" booleans nil)
    (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil) nil
    (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil)
    (zero_homomorphism? const-decl "bool" ring_homomorphisms_def nil)
    nil nil (NOT const-decl "[bool -> bool]" booleans nil)
    (one_diff_zero_coset formula-decl nil quotient_rings_with_one nil)
    (ring_natural_homo formula-decl nil ring_homomorphism_lemmas nil)
    (T2 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (s2 formal-const-decl "[T2, T2 -> T2]" ring_general_results_extras
     nil)
    (p2 formal-const-decl "[T2, T2 -> T2]" ring_general_results_extras
     nil)
    (zero2 formal-const-decl "T2" ring_general_results_extras nil) nil
    (monomorphism_charac formula-decl nil ring_homomorphism_lemmas nil)
    (TRUE const-decl "bool" booleans nil)
    (fullset const-decl "set" sets nil)
    (quotient_group_is_ring formula-decl nil quotient_rings nil)
    (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)
    (R_monomorphism? const-decl "bool" ring_homomorphisms_def nil)
    (injective? const-decl "bool" functions nil)
    (homomorphism? const-decl "bool" homomorphisms_def nil)
    (lproduct const-decl "set[T]" product_coset_def nil)
    (right_coset? const-decl "bool" cosets_def nil)
    (left_coset? const-decl "bool" cosets_def nil)
    (lc_gen const-decl "T" cosets_def nil) nil
    (member const-decl "bool" sets nil)
    (fullset_quot_group_is_ring formula-decl nil quotient_rings nil)
    (R1_is_ring formula-decl nil ring_homomorphism_lemmas nil)
    (ideal_is_coset formula-decl nil ring_cosets_lemmas nil)
    (coset_product formula-decl nil quotient_rings nil)
    (coset_add formula-decl nil quotient_rings nil)
    (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil))
   shostak))
 (mono_no_prop_id 0
  (mono_no_prop_id-1 nil 3782564950
   ("" (skeep)
    (("" (inst -1 "R_kernel(R,S)(phi)")
      (("1" (split)
        (("1" (hide 2)
          (("1" (expand "zero_homomorphism?")
            (("1" (skeep)
              (("1" (decompose-equality)
                (("1" (inst -1 "r")
                  (("1" (iff)
                    (("1" (prop)
                      (("1" (expand "R_kernel")
                        (("1" (assert) nil nil)) nil)
                       ("2" (typepred "r") (("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 1) (("2" (rewrite "monomorphism_charac") nil nil))
          nil))
        nil)
       ("2" (hide 2 3) (("2" (rewrite "R_kernel_is_ideal") nil nil))
        nil))
      nil))
    nil)
   (nil nil nil nil nil nil
    (one1 formal-const-decl "T1" ring_general_results_extras nil)
    (R_kernel const-decl "set[T1]" ring_homomorphisms_def nil)
    (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil)
    (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil)
    (zero2 formal-const-decl "T2" ring_general_results_extras nil)
    (p2 formal-const-decl "[T2, T2 -> T2]" ring_general_results_extras
     nil)
    (s2 formal-const-decl "[T2, T2 -> T2]" ring_general_results_extras
     nil)
    (T2 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (ideal? const-decl "bool" ring_ideal_def nil) nil
    (zero1 formal-const-decl "T1" ring_general_results_extras nil)
    (p1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (s1 formal-const-decl "[T1, T1 -> T1]" ring_general_results_extras
     nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T1 formal-nonempty-type-decl nil ring_general_results_extras nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (monomorphism_charac formula-decl nil ring_homomorphism_lemmas nil)
    nil (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (zero_homomorphism? const-decl "bool" ring_homomorphisms_def nil)
    (R_kernel_is_ideal formula-decl nil ring_homomorphism_lemmas nil))
   shostak))
 (teste 0
  (teste-1 nil 3813595903 ("" (skeep) (("" (postpone) nil nil)) nil)
   nil shostak)))

