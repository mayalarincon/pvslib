(groups_scaf
 (IMP_finite_groups_TCC1 0
  (IMP_finite_groups_TCC1-1 nil 3861917862
   ("" (lemma "fullset_is_group") (("" (propax) nil nil)) nil)
   ((fullset_is_group formula-decl nil groups_scaf nil)) nil
   (IMP_finite_groups assuming
    "finite_groups[groups_scaf.T, groups_scaf.*, groups_scaf.one].finite_groups"
    "fullset_is_group: ASSUMPTION group_def[finite_groups.T, finite_groups.*, finite_groups.one].group?(sets[finite_groups.T].fullset)")))
 (divby_r 0
  (divby_r-1 nil 3528491658
   ("" (skosimp*)
    (("" (prop)
      (("1" (replace -1)
        (("1" (lemma "assoc[T, *, one]")
          (("1" (inst?)
            (("1" (replace -1 1 rl)
              (("1" (rewrite "inv_right[T, *, one]")
                (("1" (rewrite "right_identity[T, *, one]") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (replace - + rl)
        (("2" (hide -1)
          (("2" (lemma "assoc[T, *, one]")
            (("2" (inst?)
              (("2" (replace -1 1 rl)
                (("2" (rewrite "inv_left[T, *, one]")
                  (("2" (rewrite "right_identity[T, *, one]") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (T formal-type-decl nil groups_scaf nil)
    (assoc formula-decl nil group nil)
    (right_identity formula-decl nil monad nil)
    (inv_right formula-decl nil group nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (inv_left formula-decl nil group nil))
   shostak))
 (subgroup_transitive 0
  (subgroup_transitive-1 nil 3528492327
   ("" (skeep)
    (("" (expand "subgroup?")
      (("" (expand* "subset?" "member")
        (("" (skosimp*)
          (("" (inst?) (("" (inst?) (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((subgroup? const-decl "bool" group_def nil)
    (T formal-type-decl nil groups_scaf nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil))
   shostak))
 (normal_subgroup_tran 0
  (normal_subgroup_tran-1 nil 3528492356
   ("" (skeep)
    (("" (expand "normal_subgroup?")
      (("" (prop)
        (("" (skosimp)
          (("" (inst?)
            (("" (expand "subgroup?" -1)
              (("" (hide-all-but (-1 1))
                (("" (expand* "subset?" "member")
                  (("" (inst?) (("" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((normal_subgroup? const-decl "boolean" normal_subgroups nil)
    (subgroup? const-decl "bool" group_def nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil) nil nil nil
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil groups_scaf nil))
   shostak))
 (subgroup_intersection 0
  (subgroup_intersection-1 nil 3528492374
   ("" (skeep)
    (("" (lemma "subgroup_def[T,*,one]")
      (("" (inst - "G" "intersection(H, K)")
        (("" (assert)
          (("" (hide 2)
            (("" (prop)
              (("1" (expand "nonempty?")
                (("1" (expand "empty?")
                  (("1" (expand "member")
                    (("1" (expand "intersection")
                      (("1" (expand "member")
                        (("1" (inst - "one")
                          (("1" (hide (-1 -2))
                            (("1" (rewrite "one_in")
                              (("1" (rewrite "one_in") nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand* "subgroup?" "subset?" "member")
                (("2" (skosimp*)
                  (("2" (inst?)
                    (("2" (inst?)
                      (("2" (expand "intersection")
                        (("2" (assert) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand "star_closed?")
                (("3" (expand "intersection")
                  (("3" (assert)
                    (("3" (skosimp*)
                      (("3" (typepred "x!1")
                        (("3" (typepred "y!1")
                          (("3" (expand "intersection")
                            (("3" (assert)
                              (("3"
                                (flatten)
                                (("3"
                                  (rewrite "product_in")
                                  (("3"
                                    (rewrite "product_in")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (hide (-1 -2))
                (("4" (expand "inv_closed?")
                  (("4" (expand "intersection")
                    (("4" (expand "member")
                      (("4" (skosimp*)
                        (("4" (typepred "x!1")
                          (("4" (expand "intersection")
                            (("4" (assert)
                              (("4"
                                (rewrite "inv_in")
                                (("4" (rewrite "inv_in") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (T formal-type-decl nil groups_scaf nil)
    (subgroup_def formula-decl nil group nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (empty? const-decl "bool" sets nil)
    (monad nonempty-type-eq-decl nil monad nil)
    (monad? const-decl "bool" monad_def nil)
    (one_in formula-decl nil monad nil)
    (member const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (subgroup? const-decl "bool" group_def nil)
    (subset? const-decl "bool" sets nil)
    (product_in formula-decl nil group nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (star_closed? const-decl "bool" groupoid_def nil)
    (inv_closed? const-decl "bool" group nil)
    (inv_in formula-decl nil group nil)
    (intersection const-decl "set" sets nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (conjugate_is_subgroup 0
  (conjugate_is_subgroup-1 nil 3531316370
   ("" (skosimp*)
    (("" (lemma "subgroup_def[T,*,one]")
      (("" (inst?)
        (("" (assert)
          (("" (hide 2)
            (("" (prop)
              (("1" (expand* "nonempty?" "empty?" "member")
                (("1" (inst -1 "one")
                  (("1" (expand "*")
                    (("1" (inst 1 "a!1")
                      (("1" (rewrite "inv_right") nil nil)
                       ("2" (inst 1 "one")
                        (("1" (assert) nil nil)
                         ("2" (rewrite "one_in") nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (typepred "H!1")
                (("2" (hide -1)
                  (("2" (expand* "subgroup?" "subset?" "member")
                    (("2" (skosimp*)
                      (("2" (expand "*")
                        (("2" (skosimp)
                          (("2" (typepred "h!1")
                            (("2" (skosimp)
                              (("2"
                                (replaces -1)
                                (("2"
                                  (replaces -2)
                                  (("2"
                                    (inst -1 "h!2")
                                    (("2"
                                      (assert)
                                      (("2"
                                        (rewrite "product_in")
                                        (("1"
                                          (hide 2)
                                          (("1"
                                            (rewrite "product_in")
                                            nil
                                            nil))
                                          nil)
                                         ("2"
                                          (hide 2)
                                          (("2"
                                            (rewrite "inv_in")
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand "star_closed?")
                (("3" (skosimp*)
                  (("3" (expand "member")
                    (("3" (typepred "x!1" "y!1")
                      (("3" (expand "*")
                        (("3" (skosimp*)
                          (("3" (typepred "h!1" "h!2")
                            (("3" (skosimp*)
                              (("3"
                                (replaces -1)
                                (("3"
                                  (replaces -1)
                                  (("3"
                                    (replaces -1)
                                    (("3"
                                      (replaces -1)
                                      (("3"
                                        (rewrite "assoc")
                                        (("3"
                                          (rewrite "assoc")
                                          (("3"
                                            (rewrite "assoc" :dir rl)
                                            (("3"
                                              (rewrite "assoc" :dir rl)
                                              (("3"
                                                (rewrite
                                                 "assoc"
                                                 :dir
                                                 rl)
                                                (("3"
                                                  (inst
                                                   1
                                                   "a!1 * h!3 * h!4")
                                                  (("3"
                                                    (inst
                                                     1
                                                     "h!3 * h!4")
                                                    (("1"
                                                      (rewrite "assoc")
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (rewrite
                                                       "product_in")
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("4" (expand "inv_closed?")
                (("4" (skosimp*)
                  (("4" (expand "member")
                    (("4" (typepred "x!1")
                      (("4" (expand "*")
                        (("4" (skosimp)
                          (("4" (typepred "h!1")
                            (("4" (skosimp)
                              (("4"
                                (replaces -1)
                                (("4"
                                  (replaces -1)
                                  (("4"
                                    (rewrite "inv_star")
                                    (("4"
                                      (rewrite "inv_star")
                                      (("4"
                                        (rewrite "assoc")
                                        (("4"
                                          (inst 1 "a!1 * inv(h!2)")
                                          (("4"
                                            (inst 1 "inv(h!2)")
                                            (("4"
                                              (rewrite "inv_in")
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (T formal-type-decl nil groups_scaf nil)
    (subgroup_def formula-decl nil group nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    nil nil nil (inv_right formula-decl nil group nil)
    (monad nonempty-type-eq-decl nil monad nil)
    (monad? const-decl "bool" monad_def nil)
    (one_in formula-decl nil monad nil)
    (one_right formula-decl nil group nil)
    (nonempty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (inv_in formula-decl nil group nil)
    (product_in formula-decl nil group nil)
    (TRUE const-decl "bool" booleans nil)
    (subset? const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil) nil nil
    (inv_left formula-decl nil group nil)
    (assoc formula-decl nil group nil)
    (star_closed? const-decl "bool" groupoid_def nil) nil
    (inv_inv formula-decl nil group nil)
    (inv_star formula-decl nil group nil)
    (inv_closed? const-decl "bool" group nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (subgroup type-eq-decl nil group nil)
    (subgroup? const-decl "bool" group_def nil) nil nil
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (center_is_normal_TCC1 0
  (center_is_normal_TCC1-1 nil 3530391030
   ("" (skosimp*)
    (("" (lemma "center_subgroup")
      (("" (inst?)
        (("" (expand "subgroup?") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (T formal-type-decl nil groups_scaf nil)
    (center_subgroup formula-decl nil group nil)
    (subgroup? const-decl "bool" group_def nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (center_is_normal subtype
    "group[groups_scaf.T, groups_scaf.*, groups_scaf.one].center(groups_scaf.G)"
    "group[T, *, one]")))
 (center_is_normal 0
  (center_is_normal-1 nil 3530391031
   ("" (skosimp)
    (("" (expand "normal_subgroup?")
      (("" (lemma "center_subgroup")
        (("" (inst?)
          (("" (assert)
            (("" (skosimp*)
              (("" (typepred "a!1")
                (("" (expand "subset?")
                  (("" (skosimp*)
                    (("" (expand "member")
                      (("" (expand "*")
                        (("" (skosimp*)
                          (("" (typepred "h!1")
                            (("" (skosimp*)
                              ((""
                                (typepred "h!2")
                                ((""
                                  (rewrite "center_def" +)
                                  ((""
                                    (prop)
                                    (("1"
                                      (replace -5)
                                      (("1"
                                        (replace -2)
                                        (("1"
                                          (typepred "center(G!1)")
                                          (("1"
                                            (expand "subset?")
                                            (("1"
                                              (assert)
                                              (("1"
                                                (inst - "h!2")
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (hide -2 -3 -5 -6)
                                                    (("1"
                                                      (lemma
                                                       "inv_member")
                                                      (("1"
                                                        (inst?)
                                                        (("1"
                                                          (inst?)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (lemma
                                                               "product_in")
                                                              (("1"
                                                                (inst?)
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (hide
                                                                     2)
                                                                    (("1"
                                                                      (lemma
                                                                       "product_in")
                                                                      (("1"
                                                                        (inst?)
                                                                        (("1"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (replace -5)
                                      (("2"
                                        (skosimp)
                                        (("2"
                                          (hide -5)
                                          (("2"
                                            (replace -2)
                                            (("2"
                                              (hide -2)
                                              (("2"
                                                (name
                                                 "w"
                                                 "inv[T, *, one](a!1)")
                                                (("2"
                                                  (replace -1)
                                                  (("2"
                                                    (hide -4)
                                                    (("2"
                                                      (rewrite
                                                       "center_def")
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (inst-cp
                                                           -3
                                                           "w")
                                                          (("1"
                                                            (replace
                                                             -4)
                                                            (("1"
                                                              (lemma
                                                               "assoc")
                                                              (("1"
                                                                (inst
                                                                 -
                                                                 "h!2"
                                                                 "w"
                                                                 "a!1")
                                                                (("1"
                                                                  (replace
                                                                   -1
                                                                   +
                                                                   rl)
                                                                  (("1"
                                                                    (replace
                                                                     -2
                                                                     +
                                                                     rl)
                                                                    (("1"
                                                                      (rewrite
                                                                       "inv_left")
                                                                      (("1"
                                                                        (assert)
                                                                        (("1"
                                                                          (inst?)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (lemma
                                                             "inv_in")
                                                            (("2"
                                                              (inst?)
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((normal_subgroup? const-decl "boolean" normal_subgroups nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (subset? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (center_def formula-decl nil group nil) nil nil nil
    (assoc formula-decl nil group nil)
    (inv_left formula-decl nil group nil)
    (one_right formula-decl nil group nil)
    (inv_in formula-decl nil group nil)
    (inv_member formula-decl nil group nil)
    (product_in formula-decl nil group nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (center const-decl "{s: set[T] | subset?(s, G)}" group nil) nil nil
    (NOT const-decl "[bool -> bool]" booleans nil)
    (center_subgroup formula-decl nil group nil)
    (T formal-type-decl nil groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (one formal-const-decl "T" groups_scaf nil))
   shostak))
 (abelian_eq_center 0
  (abelian_eq_center-1 nil 3528508011
   ("" (skosimp*)
    (("" (prop)
      (("1" (decompose-equality 1)
        (("1" (iff)
          (("1" (prop)
            (("1" (expand "abelian_group?")
              (("1" (expand* "commutative?" "center")
                (("1" (expand "extend")
                  (("1" (assert)
                    (("1" (skosimp*)
                      (("1" (inst -2 "x!2" "x!1")
                        (("1" (expand "restrict")
                          (("1" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide -2)
              (("2" (expand "center")
                (("2" (expand "extend") (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand* "abelian_group?" "commutative?")
        (("2" (skosimp*)
          (("2" (expand "restrict")
            (("2" (decompose-equality -1)
              (("2" (inst -1 "y!1")
                (("2" (iff)
                  (("2" (typepred "y!1")
                    (("2" (prop)
                      (("2" (expand* "center" "extend")
                        (("2" (inst?) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((abelian_group? const-decl "bool" group_def nil)
    (extend const-decl "R" extend nil)
    (restrict const-decl "R" restrict nil)
    (commutative? const-decl "bool" operator_defs nil)
    (T formal-type-decl nil groups_scaf nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (center const-decl "{s: set[T] | subset?(s, G)}" group nil)
    (subset? const-decl "bool" sets nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (order_gt_1 0
  (order_gt_1-1 nil 3528737004
   ("" (skosimp)
    (("" (lemma "prime_gt_1")
      (("" (inst -1 "p!1")
        (("" (assert)
          (("" (expand "divides")
            (("" (skosimp)
              (("" (hide -2)
                (("" (lemma "eq1_gt")
                  (("" (inst?)
                    (("" (assert)
                      (("" (lemma "pos_times_lt")
                        (("" (inst?) (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prime_gt_1 formula-decl nil primes ints)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (eq1_gt formula-decl nil real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pos_times_lt formula-decl nil real_props nil) nil
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (order_gt_p 0
  (order_gt_p-1 nil 3530364210
   ("" (skosimp)
    (("" (lemma "prime_gt_1")
      (("" (inst -1 "p!1")
        (("" (prop)
          (("" (expand "divides")
            (("" (skosimp)
              (("" (hide -2)
                (("" (lemma "eq1_gt")
                  (("" (inst?)
                    (("" (assert)
                      (("" (lemma "pos_times_lt")
                        (("" (inst?)
                          (("" (assert)
                            (("" (replaces -3)
                              ((""
                                (hide 1)
                                ((""
                                  (expand ">=")
                                  ((""
                                    (lemma "le_times_le_pos")
                                    ((""
                                      (inst -1 "p!1" "1" "x!1" "p!1")
                                      (("" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prime_gt_1 formula-decl nil primes ints)
    (eq1_gt formula-decl nil real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (le_times_le_pos formula-decl nil real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (pos_times_lt formula-decl nil real_props nil) nil
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (exists_diff_one 0
  (exists_diff_one-1 nil 3528736184
   ("" (skosimp)
    (("" (expand "order")
      (("" (lemma "card_2_has_2[T]")
        (("" (inst?)
          (("" (assert)
            (("" (skosimp)
              (("" (case "x!1 = one")
                (("1" (inst 2 "y!1") (("1" (assert) nil nil)) nil)
                 ("2" (inst 3 "x!1") (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((order const-decl "posnat" monad nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (one formal-const-decl "T" groups_scaf nil)
    (finite_group? const-decl "bool" group_def nil)
    (finite_group nonempty-type-eq-decl nil group nil) nil nil nil
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (card_2_has_2 formula-decl nil finite_sets nil)
    (T formal-type-decl nil groups_scaf nil))
   shostak))
 (one_iff_divides 0
  (one_iff_divides-1 nil 3528766494
   ("" (skosimp)
    (("" (prop)
      (("1" (name-replace "n!1" "period(G!1, a!1)" :hide? nil)
        (("1" (lemma "euclid_int")
          (("1" (inst -1 "n!1" "m!1")
            (("1" (skosimp)
              (("1" (case-replace "r!1 =0")
                (("1" (assert)
                  (("1" (expand "divides")
                    (("1" (inst 1 "q!1") nil nil)) nil))
                  nil)
                 ("2" (hide 2)
                  (("2" (replace -1 -3)
                    (("2" (lemma "expt_mult")
                      (("2" (inst?)
                        (("2" (lemma "expt_expt")
                          (("2" (inst?)
                            (("2" (replace -1 -2 rl)
                              (("2"
                                (replace -2 -5 rl)
                                (("2"
                                  (hide (-1 -2))
                                  (("2"
                                    (lemma "a_hat_period")
                                    (("2"
                                      (inst?)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (replace -3 -1)
                                          (("2"
                                            (replaces -1)
                                            (("2"
                                              (rewrite "one_expt")
                                              (("2"
                                                (rewrite "one_left")
                                                (("2"
                                                  (hide -1)
                                                  (("2"
                                                    (typepred "r!1")
                                                    (("2"
                                                      (expand "period")
                                                      (("2"
                                                        (lemma
                                                         "min_def[posnat]")
                                                        (("2"
                                                          (inst?)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (expand
                                                               "minimum?")
                                                              (("1"
                                                                (inst?)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (expand
                                                             "nonempty?")
                                                            (("2"
                                                              (expand
                                                               "empty?")
                                                              (("2"
                                                                (inst?)
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "divides")
        (("2" (skosimp)
          (("2" (replaces -1)
            (("2" (lemma "expt_expt")
              (("2" (inst?)
                (("2" (lemma "a_hat_period")
                  (("2" (inst?)
                    (("2" (assert)
                      (("2" (replaces -1)
                        (("2" (rewrite "one_expt")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((euclid_int formula-decl nil euclidean_division nil)
    (expt_mult formula-decl nil group nil)
    (expt_expt formula-decl nil group nil)
    (one_expt formula-decl nil group nil)
    (nonempty? const-decl "bool" sets nil) nil nil
    (minimum? const-decl "bool" min_nat nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (empty? const-decl "bool" sets nil)
    (min_def formula-decl nil min_nat nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (one_left formula-decl nil group nil) (^ const-decl "T" group nil)
    (TRUE const-decl "bool" booleans nil)
    (member const-decl "bool" sets nil)
    (a_hat_period formula-decl nil finite_groups nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil) nil
    (int_times_int_is_int application-judgement "int" integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (period const-decl "posnat" finite_groups nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (finite_group? const-decl "bool" group_def nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (finite_group nonempty-type-eq-decl nil group nil)
    (one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (T formal-type-decl nil groups_scaf nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (order_power_TCC1 0
  (order_power_TCC1-1 nil 3528766942
   ("" (skosimp)
    (("" (lemma "expt_member")
      (("" (inst -1 "G!1" "a!1" "k!1") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (T formal-type-decl nil groups_scaf nil)
    (expt_member formula-decl nil group nil)
    (member const-decl "bool" sets nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_group nonempty-type-eq-decl nil group nil)
    (finite_group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (order_power subtype
    "group[groups_scaf.T, groups_scaf.*, groups_scaf.one].^(groups_scaf.a, groups_scaf.k)"
    "(groups_scaf.G)")))
 (order_power_TCC2 0
  (order_power_TCC2-1 nil 3528766942 ("" (subtype-tcc) nil nil)
   ((^ const-decl "T" group nil)
    (one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (T formal-type-decl nil groups_scaf nil)
    (period const-decl "posnat" finite_groups nil))
   nil
   (order_power subtype "groups_scaf.n"
    "{jj: integers.int | booleans.=>(groups_scaf.k = 0, jj /= 0)}")))
 (order_power 0
  (order_power-1 nil 3528767077
   ("" (skosimp)
    (("" (skoletin 1)
      (("" (case "(a!1^k!1)^(n / gcd(k!1, n)) = one")
        (("1" (lemma "one_iff_divides")
          (("1" (inst -1 "(n / gcd(k!1, n))" "G!1" "a!1^k!1")
            (("1" (assert)
              (("1"
                (name-replace "m!1" "period(G!1, a!1 ^ k!1)" :hide?
                 nil)
                (("1" (case "a!1^(k!1*m!1) = one")
                  (("1" (lemma "one_iff_divides")
                    (("1" (inst -1 "k!1 * m!1" "G!1" "a!1")
                      (("1" (assert)
                        (("1" (hide (-2 -5))
                          (("1" (replace -4 -1 rl)
                            (("1"
                              (case "divides(n/gcd(k!1, n) , (k!1/gcd(k!1, n))*m!1 )")
                              (("1"
                                (lemma "gcd_div_by_gcd")
                                (("1"
                                  (inst -1 "n" "k!1")
                                  (("1"
                                    (expand "div_by_gcd")
                                    (("1"
                                      (rewrite "gcd_sym")
                                      (("1"
                                        (lemma "rel_prime_div_prod")
                                        (("1"
                                          (expand "rel_prime")
                                          (("1"
                                            (inst?)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (lemma
                                                 "mutual_divisors_nat")
                                                (("1"
                                                  (inst
                                                   -1
                                                   "n / gcd(k!1, n)"
                                                   "m!1")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (hide-all-but 1)
                                                    (("2"
                                                      (rewrite
                                                       "gcd_sym")
                                                      (("2"
                                                        (lemma
                                                         "div_by_gcd_prep")
                                                        (("2"
                                                          (inst?)
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (hide-all-but 1)
                                              (("2"
                                                (lemma
                                                 "div_by_gcd_prep")
                                                (("2"
                                                  (inst -1 "k!1" "n")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (hide-all-but 1)
                                              (("3"
                                                (rewrite "gcd_sym")
                                                (("3"
                                                  (lemma
                                                   "div_by_gcd_prep")
                                                  (("3"
                                                    (inst -1 "n" "k!1")
                                                    (("3"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide-all-but (-1 1))
                                (("2"
                                  (expand "divides")
                                  (("2"
                                    (skosimp)
                                    (("2"
                                      (inst 1 "x!1")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (hide-all-but 1)
                                (("3"
                                  (lemma "div_by_gcd_prep")
                                  (("3"
                                    (inst -1 "k!1" "n")
                                    (("3"
                                      (flatten)
                                      (("3"
                                        (rewrite "closed_times")
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but (-1 1))
                    (("2" (rewrite "expt_expt" :dir rl)
                      (("2" (lemma "a_hat_period")
                        (("2" (inst?)
                          (("2" (assert)
                            (("2" (hide (-1 2))
                              (("2"
                                (lemma "expt_member")
                                (("2"
                                  (inst -1 "G!1" "a!1" "k!1")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but 1)
              (("2" (rewrite "gcd_sym")
                (("2" (lemma "div_by_gcd_prep")
                  (("2" (inst -1 "n" "k!1") (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (rewrite "expt_expt")
            (("2" (rewrite "times_div1")
              (("2" (rewrite "commutative_mult")
                (("2" (rewrite "times_div1" :dir rl)
                  (("2" (rewrite "expt_expt" :dir rl)
                    (("1" (lemma "a_hat_period")
                      (("1" (inst?)
                        (("1" (assert)
                          (("1" (replace -2 -1 rl)
                            (("1" (replaces -1)
                              (("1"
                                (rewrite "one_expt")
                                (("1"
                                  (hide-all-but 1)
                                  (("1"
                                    (lemma "div_by_gcd_prep")
                                    (("1"
                                      (inst -1 "k!1" "n")
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but 1)
                      (("2" (lemma "div_by_gcd_prep")
                        (("2" (inst -1 "k!1" "n")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (hide-all-but 1)
          (("3" (rewrite "gcd_sym")
            (("3" (lemma "div_by_gcd_prep")
              (("3" (inst -1 "n" "k!1") (("3" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (one formal-const-decl "T" groups_scaf nil)
    (finite_group nonempty-type-eq-decl nil group nil)
    (set type-eq-decl nil sets nil)
    (finite_group? const-decl "bool" group_def nil)
    (period const-decl "posnat" finite_groups nil)
    (^ const-decl "T" group nil) (/= const-decl "boolean" notequal nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (gcd const-decl "{k: posnat | divides(k, i) AND divides(k, j)}" gcd
         ints)
    (divides const-decl "bool" divides nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (times_div1 formula-decl nil real_props nil)
    (one_expt formula-decl nil group nil)
    (commutative_mult formula-decl nil number_fields nil)
    (one_iff_divides formula-decl nil groups_scaf nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (gcd_sym formula-decl nil gcd ints)
    (rel_prime const-decl "bool" gcd ints)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (div_by_gcd_prep formula-decl nil gcd_fractions ints)
    (mutual_divisors_nat formula-decl nil divides nil)
    (rel_prime_div_prod formula-decl nil gcd ints)
    (div_by_gcd const-decl "posint" gcd_fractions ints)
    (gcd_div_by_gcd formula-decl nil gcd_fractions ints)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (closed_times formula-decl nil integers nil)
    (expt_expt formula-decl nil group nil)
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (expt_member formula-decl nil group nil)
    (member const-decl "bool" sets nil)
    (a_hat_period formula-decl nil finite_groups nil)
    (k!1 skolem-const-decl "posnat" groups_scaf nil)
    (n skolem-const-decl "posnat" groups_scaf nil))
   shostak))
 (coset_power_nat_TCC1 0
  (coset_power_nat_TCC1-1 nil 3530393554
   ("" (skosimp*) (("" (inst?) nil nil)) nil)
   ((group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil groups_scaf nil))
   nil
   (coset_power_nat subtype
    "cosets[groups_scaf.T, groups_scaf.*, groups_scaf.one].*(groups_scaf.x, groups_scaf.H)"
    "cosets[groups_scaf.T, groups_scaf.*, groups_scaf.one].left_cosets(groups_scaf.G, groups_scaf.H)")))
 (coset_power_nat_TCC2 0
  (coset_power_nat_TCC2-1 nil 3530393554
   ("" (skosimp*)
    (("" (inst 1 "H!1")
      (("" (inst 1 "one")
        (("1" (rewrite "left_coset_one") nil nil)
         ("2" (rewrite "one_in") nil nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil groups_scaf nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (one formal-const-decl "T" groups_scaf nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil
    (normal_subgroup? const-decl "boolean" normal_subgroups nil)
    (normal_subgroup type-eq-decl nil normal_subgroups nil)
    (left_cosets type-eq-decl nil cosets nil) nil nil
    (monad nonempty-type-eq-decl nil monad nil)
    (monad? const-decl "bool" monad_def nil)
    (one_in formula-decl nil monad nil)
    (left_coset_one formula-decl nil cosets nil))
   nil
   (coset_power_nat existence ""
    "cosets[groups_scaf.T, groups_scaf.*, groups_scaf.one].left_cosets(groups_scaf.G, groups_scaf.H)")))
 (coset_power_nat_TCC3 0
  (coset_power_nat_TCC3-1 nil 3530393611
   ("" (skosimp*)
    (("" (inst 1 "one")
      (("1" (rewrite "left_coset_one") nil nil)
       ("2" (rewrite "one_in") nil nil))
      nil))
    nil)
   (nil (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil groups_scaf nil)
    (normal_subgroup type-eq-decl nil normal_subgroups nil)
    (normal_subgroup? const-decl "boolean" normal_subgroups nil)
    (left_coset_one formula-decl nil cosets nil)
    (monad nonempty-type-eq-decl nil monad nil)
    (monad? const-decl "bool" monad_def nil)
    (one_in formula-decl nil monad nil))
   nil
   (coset_power_nat subtype "groups_scaf.H"
    "cosets[groups_scaf.T, groups_scaf.*, groups_scaf.one].left_cosets(groups_scaf.G, groups_scaf.H)")))
 (coset_power_nat_TCC4 0
  (coset_power_nat_TCC4-1 nil 3530393611
   ("" (skosimp*)
    (("" (rewrite "left_cosets_group[T, *, one]") nil nil)) nil)
   ((left_cosets_group formula-decl nil factor_groups nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (normal_subgroup? const-decl "boolean" normal_subgroups nil)
    (normal_subgroup type-eq-decl nil normal_subgroups nil)
    (T formal-type-decl nil groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (one formal-const-decl "T" groups_scaf nil))
   nil
   (coset_power_nat assuming
    "group[cosets[groups_scaf.T, groups_scaf.*, groups_scaf.one].left_cosets(groups_scaf.G, groups_scaf.H), factor_groups[groups_scaf.T, groups_scaf.*, groups_scaf.one].mult(groups_scaf.G, groups_scaf.H), groups_scaf.H].group"
    "fullset_is_group: ASSUMPTION group_def[group.T, group.*, group.one].group?(sets[group.T].fullset)")))
 (coset_power_nat 0
  (coset_power_nat-1 nil 3530393556
   ("" (induct "i")
    (("1" (skosimp*)
      (("1" (expand "^" 1 1)
        (("1" (expand "power")
          (("1" (rewrite "expt_0")
            (("1" (rewrite "left_coset_one") nil nil)) nil))
          nil))
        nil))
      nil)
     ("2" (skosimp*)
      (("2" (inst?)
        (("2" (expand "^" -1 1)
          (("2" (expand "^" 1 1)
            (("2" (expand "power" 1)
              (("2" (replaces -1)
                (("2" (lemma "mult_lem[T,*,one]")
                  (("2" (inst?)
                    (("1" (replaces -1)
                      (("1" (rewrite "expt_mult" :dir rl)
                        (("1" (rewrite "expt_1") nil nil)) nil))
                      nil)
                     ("2" (hide 2)
                      (("2" (lemma "expt_member")
                        (("2" (inst -1 "G!1" "x!1" "j!1")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skosimp*)
        (("3" (inst 1 "one")
          (("1" (rewrite "left_coset_one") nil nil)
           ("2" (rewrite "one_in") nil nil))
          nil))
        nil))
      nil)
     ("4" (hide 2)
      (("4" (skosimp*) (("4" (inst 1 "x!1") nil nil)) nil)) nil))
    nil)
   (nil (one_in formula-decl nil monad nil)
    (monad? const-decl "bool" monad_def nil)
    (monad nonempty-type-eq-decl nil monad nil)
    (mult_lem formula-decl nil factor_groups nil)
    (member const-decl "bool" sets nil)
    (expt_member formula-decl nil group nil)
    (expt_1 formula-decl nil group nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (expt_mult formula-decl nil group nil) nil nil nil
    (TRUE const-decl "bool" booleans nil)
    (power def-decl "T" monoid_def nil)
    (left_coset_one formula-decl nil cosets nil)
    (expt_0 formula-decl nil group nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (^ const-decl "T" group nil)
    (mult const-decl "left_cosets(G, H)" factor_groups nil)
    (left_cosets type-eq-decl nil cosets nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (T formal-type-decl nil groups_scaf nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (one formal-const-decl "T" groups_scaf nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (normal_subgroup? const-decl "boolean" normal_subgroups nil)
    (normal_subgroup type-eq-decl nil normal_subgroups nil)
    (= const-decl "[T, T -> boolean]" equalities nil) nil)
   shostak))
 (coset_power_int 0
  (coset_power_int-1 nil 3530393638
   ("" (skosimp*)
    (("" (case "m!1 < 0")
      (("1" (expand "^")
        (("1" (assert)
          (("1"
            (case-replace
             "inv[left_cosets(G!1,H!1),mult(G!1,H!1),H!1](x!1 * H!1) = inv(x!1) * H!1"
             :hide? T)
            (("1" (lemma "coset_power_nat")
              (("1" (inst -1 "G!1" "-m!1" "inv(x!1)" "H!1")
                (("1" (expand "^" -1) (("1" (propax) nil nil)) nil)
                 ("2" (hide (-1 2)) (("2" (rewrite "inv_in") nil nil))
                  nil))
                nil))
              nil)
             ("2" (hide (-1 2))
              (("2" (lemma "mult_lem[T,*,one]")
                (("2" (inst -1 "G!1" "H!1" "x!1" "inv(x!1)")
                  (("1" (rewrite "inv_right")
                    (("1" (rewrite "left_coset_one")
                      (("1" (lemma "mult_lem[T,*,one]")
                        (("1" (inst -1 "G!1" "H!1" "inv(x!1)" "x!1")
                          (("1" (rewrite "inv_left")
                            (("1" (rewrite "left_coset_one")
                              (("1"
                                (lemma
                                 "unique_inv[left_cosets(G!1,H!1),mult(G!1,H!1),H!1]")
                                (("1"
                                  (inst
                                   -1
                                   "x!1 * H!1"
                                   "inv(x!1) * H!1")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (hide-all-but 1)
                                  (("2"
                                    (inst 1 "one")
                                    (("1"
                                      (rewrite "left_coset_one")
                                      nil
                                      nil)
                                     ("2" (rewrite "one_in") nil nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (hide-all-but 1)
                                  (("3"
                                    (inst 1 "H!1")
                                    (("3"
                                      (inst 1 "one")
                                      (("1"
                                        (rewrite "left_coset_one")
                                        nil
                                        nil)
                                       ("2"
                                        (rewrite "one_in")
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1)
                            (("2" (rewrite "inv_in") nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2) (("2" (rewrite "inv_in") nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (hide-all-but 1)
              (("3" (inst 1 "one")
                (("1" (rewrite "left_coset_one") nil nil)
                 ("2" (rewrite "one_in") nil nil))
                nil))
              nil)
             ("4" (hide-all-but 1)
              (("4" (inst 1 "H!1")
                (("4" (inst 1 "one")
                  (("1" (rewrite "left_coset_one") nil nil)
                   ("2" (rewrite "one_in") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (lemma "coset_power_nat")
        (("2" (inst -1 "G!1" "m!1" "x!1" "H!1")
          (("2" (hide 3) (("2" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (left_coset_one formula-decl nil cosets nil) nil
    (monad nonempty-type-eq-decl nil monad nil)
    (monad? const-decl "bool" monad_def nil)
    (one_in formula-decl nil monad nil)
    (unique_inv formula-decl nil group nil)
    (inv_left formula-decl nil group nil)
    (inv_right formula-decl nil group nil)
    (mult_lem formula-decl nil factor_groups nil)
    (coset_power_nat formula-decl nil groups_scaf nil)
    (inv_in formula-decl nil group nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil) nil nil
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (inv const-decl "{y | x * y = one AND y * x = one}" group nil)
    (mult const-decl "left_cosets(G, H)" factor_groups nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (left_cosets type-eq-decl nil cosets nil)
    (normal_subgroup type-eq-decl nil normal_subgroups nil)
    (normal_subgroup? const-decl "boolean" normal_subgroups nil) nil
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (set type-eq-decl nil sets nil)
    (T formal-type-decl nil groups_scaf nil)
    (TRUE const-decl "bool" booleans nil) (^ const-decl "T" group nil)
    nil)
   shostak))
 (factor_of_cyclic_is_cyclic_TCC1 0
  (factor_of_cyclic_is_cyclic_TCC1-1 nil 3810218701
   ("" (skosimp)
    (("" (lemma "cyclic_abelian[T, *, one]")
      (("1" (inst -1 "G!1")
        (("1" (assert)
          (("1" (lemma "abelian_normal[T, *, one]")
            (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
          nil))
        nil)
       ("2" (hide (- 2)) (("2" (rewrite "fullset_is_group") nil nil))
        nil))
      nil))
    nil)
   ((one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (T formal-type-decl nil groups_scaf nil)
    (cyclic_abelian formula-decl nil cyclic_group nil)
    (fullset const-decl "set" sets nil)
    (group? const-decl "bool" group_def nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (abelian_normal formula-decl nil normal_subgroups nil)
    (group nonempty-type-eq-decl nil group nil)
    (fullset_is_group formula-decl nil groups_scaf nil))
   nil
   (factor_of_cyclic_is_cyclic subtype "groups_scaf.N"
    "normal_subgroups[groups_scaf.T, groups_scaf.*, groups_scaf.one].normal_subgroup(groups_scaf.G)")))
 (factor_of_cyclic_is_cyclic_TCC2 0
  (factor_of_cyclic_is_cyclic_TCC2-1 nil 3810218701
   ("" (skosimp)
    (("" (inst 1 "one")
      (("1" (rewrite "left_coset_one") nil nil)
       ("2" (rewrite "one_in") nil nil))
      nil))
    nil)
   (nil (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-type-decl nil groups_scaf nil)
    (left_coset_one formula-decl nil cosets nil)
    (monad nonempty-type-eq-decl nil monad nil)
    (monad? const-decl "bool" monad_def nil)
    (one_in formula-decl nil monad nil))
   nil
   (factor_of_cyclic_is_cyclic subtype "groups_scaf.N"
    "cosets[groups_scaf.T, groups_scaf.*, groups_scaf.one].left_cosets(groups_scaf.G, groups_scaf.N)")))
 (factor_of_cyclic_is_cyclic_TCC3 0
  (factor_of_cyclic_is_cyclic_TCC3-1 nil 3810218701
   ("" (skosimp)
    (("" (rewrite "left_cosets_group[T, *, one]")
      (("" (hide 2)
        (("" (lemma "cyclic_abelian[T, *, one]")
          (("1" (inst -1 "G!1")
            (("1" (assert)
              (("1" (lemma "abelian_normal[T, *, one]")
                (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
              nil))
            nil)
           ("2" (hide (- 2))
            (("2" (rewrite "fullset_is_group") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((left_cosets_group formula-decl nil factor_groups nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (group? const-decl "bool" group_def nil)
    (group nonempty-type-eq-decl nil group nil)
    (normal_subgroup? const-decl "boolean" normal_subgroups nil)
    (normal_subgroup type-eq-decl nil normal_subgroups nil)
    (T formal-type-decl nil groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (one formal-const-decl "T" groups_scaf nil)
    (cyclic_abelian formula-decl nil cyclic_group nil)
    (fullset const-decl "set" sets nil)
    (abelian_normal formula-decl nil normal_subgroups nil)
    (fullset_is_group formula-decl nil groups_scaf nil))
   nil
   (factor_of_cyclic_is_cyclic assuming
    "group[cosets[groups_scaf.T, groups_scaf.*, groups_scaf.one].left_cosets(groups_scaf.G, groups_scaf.N), factor_groups[groups_scaf.T, groups_scaf.*, groups_scaf.one].mult(groups_scaf.G, groups_scaf.N), groups_scaf.N].group"
    "fullset_is_group: ASSUMPTION group_def[group.T, group.*, group.one].group?(sets[group.T].fullset)")))
 (factor_of_cyclic_is_cyclic 0
  (factor_of_cyclic_is_cyclic-1 nil 3810218747
   ("" (skosimp*)
    (("" (expand "cyclic?")
      (("" (skosimp)
        (("" (inst 1 "a!1*N!1")
          (("1" (decompose-equality 1)
            (("1" (iff)
              (("1" (prop)
                (("1" (expand "generated_by" 1)
                  (("1" (expand "/")
                    (("1" (expand "restrict")
                      (("1" (expand "left_cosets")
                        (("1" (skosimp)
                          (("1" (typepred "a!2")
                            (("1" (replace -3 -1)
                              (("1"
                                (expand "generated_by" -1)
                                (("1"
                                  (skosimp)
                                  (("1"
                                    (replaces -1)
                                    (("1"
                                      (replaces -1)
                                      (("1"
                                        (inst?)
                                        (("1"
                                          (lemma "coset_power_int")
                                          (("1"
                                            (inst?)
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (hide 2)
                                              (("2"
                                                (lemma
                                                 "cyclic_abelian[T, *, one]")
                                                (("1"
                                                  (inst -1 "G!1")
                                                  (("1"
                                                    (prop)
                                                    (("1"
                                                      (lemma
                                                       "abelian_normal[T, *, one]")
                                                      (("1"
                                                        (inst?)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide (-2 2))
                                                      (("2"
                                                        (expand
                                                         "cyclic?")
                                                        (("2"
                                                          (inst?)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide (- 2))
                                                  (("2"
                                                    (rewrite
                                                     "fullset_is_group")
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "generated_by" -1)
                  (("2" (skosimp)
                    (("2" (expand "/")
                      (("2" (expand "restrict")
                        (("2" (expand "left_cosets")
                          (("2" (inst 1 "a!1 ^ i!1")
                            (("1" (replaces -1)
                              (("1"
                                (lemma "coset_power_int")
                                (("1"
                                  (inst?)
                                  (("1"
                                    (hide 2)
                                    (("1"
                                      (lemma
                                       "cyclic_abelian[T, *, one]")
                                      (("1"
                                        (inst -1 "G!1")
                                        (("1"
                                          (prop)
                                          (("1"
                                            (lemma
                                             "abelian_normal[T, *, one]")
                                            (("1"
                                              (inst?)
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (hide (-2 2))
                                            (("2"
                                              (expand "cyclic?")
                                              (("2" (inst?) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (hide (- 2))
                                        (("2"
                                          (rewrite "fullset_is_group")
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide (-1 -3))
                              (("2"
                                (lemma "expt_member")
                                (("2"
                                  (inst -1 "G!1" "a!1" "i!1")
                                  (("2"
                                    (expand "member")
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (rewrite "left_cosets_group[T, *, one]")
              (("2" (hide 2)
                (("2" (lemma "cyclic_abelian[T, *, one]")
                  (("1" (inst -1 "G!1")
                    (("1" (prop)
                      (("1" (lemma "abelian_normal[T, *, one]")
                        (("1" (inst?) (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (hide (-2 2))
                        (("2" (expand "cyclic?")
                          (("2" (inst?) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide (- 2))
                    (("2" (rewrite "fullset_is_group") nil nil)) nil))
                  nil))
                nil))
              nil)
             ("3" (inst 1 "one")
              (("1" (rewrite "left_coset_one") nil nil)
               ("2" (rewrite "one_in") nil nil))
              nil)
             ("4" (rewrite "fullset_is_group") nil nil))
            nil)
           ("2" (prop)
            (("1" (inst?) nil nil)
             ("2" (expand "/")
              (("2" (expand "restrict")
                (("2" (expand "left_cosets") (("2" (inst?) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cyclic? const-decl "boolean" group nil)
    (/ const-decl "group[left_cosets[T, *, one](G, N), mult(G, N), N]"
       right_left_cosets nil)
    (mult const-decl "left_cosets(G, H)" factor_groups nil)
    (left_cosets type-eq-decl nil cosets nil)
    (normal_subgroup type-eq-decl nil normal_subgroups nil)
    (normal_subgroup? const-decl "boolean" normal_subgroups nil) nil
    nil nil (= const-decl "[T, T -> boolean]" equalities nil) nil
    (group nonempty-type-eq-decl nil group nil)
    (group? const-decl "bool" group_def nil)
    (one formal-const-decl "T" groups_scaf nil)
    (* formal-const-decl "[T, T -> T]" groups_scaf nil)
    (set type-eq-decl nil sets nil)
    (T formal-type-decl nil groups_scaf nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (left_coset_one formula-decl nil cosets nil)
    (one_in formula-decl nil monad nil)
    (monad? const-decl "bool" monad_def nil)
    (monad nonempty-type-eq-decl nil monad nil)
    (left_cosets_group formula-decl nil factor_groups nil)
    (member const-decl "bool" sets nil)
    (expt_member formula-decl nil group nil) nil
    (^ const-decl "T" group nil) (restrict const-decl "R" restrict nil)
    (coset_power_int formula-decl nil groups_scaf nil)
    (fullset_is_group formula-decl nil groups_scaf nil)
    (abelian_normal formula-decl nil normal_subgroups nil)
    (cyclic_abelian formula-decl nil cyclic_group nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (left_cosets const-decl "setofsets[T]" right_left_cosets nil)
    (generated_by const-decl "group" group nil)
    (fullset const-decl "set" sets nil))
   shostak)))

