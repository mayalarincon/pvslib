(commutative_ring
 (IMP_ring_TCC1 0
  (IMP_ring_TCC1-1 nil 3293981068
   ("" (lemma "fullset_is_commutative_ring")
    (("" (expand "commutative_ring?") (("" (flatten) nil nil)) nil))
    nil)
   ((commutative_ring? const-decl "bool" ring_def nil)
    (fullset_is_commutative_ring formula-decl nil commutative_ring
     nil))
   shostak
   (IMP_ring assuming
    "ring[commutative_ring.T, commutative_ring.+, commutative_ring.*, commutative_ring.zero].ring"
    "fullset_is_ring: ASSUMPTION ring_def[ring.T, ring.+, ring.*, ring.zero].ring?(sets[ring.T].fullset)")))
 (commutative_ring_TCC1 0
  (commutative_ring_TCC1-1 nil 3293981068
   ("" (lemma "fullset_is_commutative_ring") (("" (propax) nil nil))
    nil)
   ((fullset_is_commutative_ring formula-decl nil commutative_ring
     nil))
   shostak
   (commutative_ring subtype "sets[commutative_ring.T].fullset"
    "commutative_ring")))
 (times_commutative 0
  (times_commutative-1 nil 3293981087
   ("" (lemma "fullset_is_commutative_ring")
    (("" (expand "commutative_ring?")
      (("" (flatten)
        (("" (expand "commutative?")
          (("" (expand "restrict")
            (("" (skosimp)
              (("" (inst - "x!1" "y!1")
                (("1" (expand "fullset") (("1" (propax) nil nil)) nil)
                 ("2" (expand "fullset") (("2" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((commutative_ring? const-decl "bool" ring_def nil)
    (commutative? const-decl "bool" operator_defs nil) nil nil
    (fullset const-decl "set" sets nil) (set type-eq-decl nil sets nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (T formal-nonempty-type-decl nil commutative_ring nil)
    (restrict const-decl "R" restrict nil)
    (fullset_is_commutative_ring formula-decl nil commutative_ring
     nil))
   shostak))
 (commutative_ring_is_ring 0
  (commutative_ring_is_ring-1 nil 3885448261
   ("" (judgement-tcc) nil nil)
   ((commutative_ring nonempty-type-eq-decl nil commutative_ring nil)
    (commutative_ring? const-decl "bool" ring_def nil)
    (set type-eq-decl nil sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (member const-decl "bool" sets nil)
    (star_closed? const-decl "bool" groupoid_def nil)
    (zero formal-const-decl "T" commutative_ring nil)
    (+ formal-const-decl "[T, T -> T]" commutative_ring nil)
    (T formal-nonempty-type-decl nil commutative_ring nil)
    (one_member formula-decl nil monad nil)
    (right_identity formula-decl nil monad nil)
    (restrict const-decl "R" restrict nil)
    (left_identity formula-decl nil monad nil)
    (identity? const-decl "bool" operator_defs nil)
    (monad? const-decl "bool" monad_def nil)
    (associative? const-decl "bool" operator_defs nil)
    (monoid? const-decl "bool" monoid_def nil)
    (inv_exists? const-decl "bool" group_def nil)
    (group? const-decl "bool" group_def nil)
    (commutative? const-decl "bool" operator_defs nil)
    (abelian_group? const-decl "bool" group_def nil)
    (left_distributive? const-decl "bool" operator_defs_more nil)
    (right_distributive? const-decl "bool" operator_defs_more nil)
    (* formal-const-decl "[T, T -> T]" commutative_ring nil)
    (ring? const-decl "bool" ring_def nil))
   nil
   (commutative_ring_is_ring_ subtype
    "commutative_ring.commutative_ring"
    "ring[commutative_ring.T, commutative_ring.+, commutative_ring.*, commutative_ring.zero].ring")))
 (commutative_subrings 0
  (commutative_subrings-1 nil 3294090987
   ("" (skosimp)
    (("" (typepred "R!1")
      (("" (expand "subring?")
        (("" (expand "commutative_ring?")
          (("" (flatten)
            (("" (assert)
              (("" (expand "commutative?")
                (("" (expand "restrict")
                  (("" (expand "subset?")
                    (("" (expand "member")
                      (("" (skosimp)
                        (("" (inst-cp - "x!1")
                          (("" (inst - "y!1")
                            (("" (assert)
                              (("" (inst - "x!1" "y!1") nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((commutative_ring nonempty-type-eq-decl nil commutative_ring nil)
    (commutative_ring? const-decl "bool" ring_def nil)
    (zero formal-const-decl "T" commutative_ring nil)
    (* formal-const-decl "[T, T -> T]" commutative_ring nil)
    (+ formal-const-decl "[T, T -> T]" commutative_ring nil)
    (set type-eq-decl nil sets nil)
    (T formal-nonempty-type-decl nil commutative_ring nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (subset_is_partial_order name-judgement "(partial_order?[set[T]])"
     sets_lemmas nil)
    (restrict const-decl "R" restrict nil)
    (member const-decl "bool" sets nil)
    (subset? const-decl "bool" sets nil)
    (commutative? const-decl "bool" operator_defs nil)
    (subring? const-decl "bool" ring_def nil))
   shostak))
 (sq_times 0
  (sq_times-1 nil 3297002583
   ("" (skosimp)
    (("" (expand "sq")
      (("" (lemma "times_associative")
        (("" (rewrite "times_associative")
          (("" (rewrite "times_associative")
            (("" (inst-cp - "y!1" "x!1" "y!1")
              (("" (inst - "x!1" "y!1" "y!1")
                (("" (lemma "times_commutative" ("x" "x!1" "y" "y!1"))
                  (("" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sq const-decl "T" ring nil)
    (times_commutative formula-decl nil commutative_ring nil)
    (times_associative formula-decl nil ring nil)
    (T formal-nonempty-type-decl nil commutative_ring nil)
    (+ formal-const-decl "[T, T -> T]" commutative_ring nil)
    (* formal-const-decl "[T, T -> T]" commutative_ring nil)
    (zero formal-const-decl "T" commutative_ring nil))
   shostak)))

