(ring_homomorphism_lemmas_extras
 (IMP_quotient_rings_TCC1 0
  (IMP_quotient_rings_TCC1-1 nil 3908449360
   ("" (rewrite "R1_is_ring") nil nil)
   ((R1_is_ring formula-decl nil ring_homomorphism_lemmas_extras nil))
   nil
   (IMP_quotient_rings assuming
    "quotient_rings[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1, ring_homomorphism_lemmas_extras.p1, ring_homomorphism_lemmas_extras.zero1].quotient_rings"
    "fullset_is_ring: ASSUMPTION ring_def[quotient_rings.T, quotient_rings.+, quotient_rings.*, quotient_rings.zero].ring?(sets[quotient_rings.T].fullset)")))
 (zero_natural_isomorphism_TCC1 0
  (zero_natural_isomorphism_TCC1-1 nil 3908449360
   ("" (skeep)
    (("" (inst 1 "singleton(zero1)")
      (("" (rewrite "ideal_is_coset")
        (("" (rewrite "zero_ideal") nil nil)) nil))
      nil))
    nil)
   ((nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas_extras
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (s1 formal-const-decl "[T1, T1 -> T1]"
     ring_homomorphism_lemmas_extras nil)
    (coset? const-decl "bool" cosets_def nil)
    (p1 formal-const-decl "[T1, T1 -> T1]"
     ring_homomorphism_lemmas_extras nil)
    (zero1 formal-const-decl "T1" ring_homomorphism_lemmas_extras nil)
    (ring? const-decl "bool" ring_def nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (coset type-eq-decl nil cosets_def nil)
    (S skolem-const-decl "ring[T1, s1, p1, zero1]"
     ring_homomorphism_lemmas_extras nil)
    (zero_ideal formula-decl nil ring_ideal nil)
    (ideal_is_coset formula-decl nil ring_cosets_lemmas nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil))
   nil
   (zero_natural_isomorphism existence ""
    "cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))")))
 (zero_natural_isomorphism_TCC2 0
  (zero_natural_isomorphism_TCC2-1 nil 3908449360
   ("" (skeep)
    (("" (lemma "coset_add")
      (("" (inst -1 "S" "singleton[T1](zero1)" "x1`1" "x1`2")
        (("1" (assert) nil nil)
         ("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil)) nil))
        nil))
      nil))
    nil)
   ((zero1 formal-const-decl "T1" ring_homomorphism_lemmas_extras nil)
    (p1 formal-const-decl "[T1, T1 -> T1]"
     ring_homomorphism_lemmas_extras nil)
    (s1 formal-const-decl "[T1, T1 -> T1]"
     ring_homomorphism_lemmas_extras nil)
    (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas_extras
     nil)
    (coset_add formula-decl nil quotient_rings nil)
    (zero_ideal formula-decl nil ring_ideal nil)
    (coset type-eq-decl nil cosets_def nil)
    (coset? const-decl "bool" cosets_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring? const-decl "bool" ring_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (S skolem-const-decl "ring[T1, s1, p1, zero1]"
     ring_homomorphism_lemmas_extras nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil))
   nil
   (zero_natural_isomorphism subtype
    "cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].add(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))"
    "[[cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1)), cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))] -> cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))]")))
 (zero_natural_isomorphism_TCC3 0
  (zero_natural_isomorphism_TCC3-1 nil 3908449360
   ("" (skeep)
    (("" (lemma "coset_product")
      (("" (inst -1 "S" "singleton[T1](zero1)" "x1`1" "x1`2")
        (("1" (assert) nil nil)
         ("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil)) nil))
        nil))
      nil))
    nil)
   ((zero1 formal-const-decl "T1" ring_homomorphism_lemmas_extras nil)
    (p1 formal-const-decl "[T1, T1 -> T1]"
     ring_homomorphism_lemmas_extras nil)
    (s1 formal-const-decl "[T1, T1 -> T1]"
     ring_homomorphism_lemmas_extras nil)
    (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas_extras
     nil)
    (coset_product formula-decl nil quotient_rings nil)
    (zero_ideal formula-decl nil ring_ideal nil)
    (coset type-eq-decl nil cosets_def nil)
    (coset? const-decl "bool" cosets_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring? const-decl "bool" ring_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (S skolem-const-decl "ring[T1, s1, p1, zero1]"
     ring_homomorphism_lemmas_extras nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil))
   nil
   (zero_natural_isomorphism subtype
    "product_coset_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1, ring_homomorphism_lemmas_extras.p1].product(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))"
    "[[cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1)), cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))] -> cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))]")))
 (zero_natural_isomorphism_TCC4 0
  (zero_natural_isomorphism_TCC4-1 nil 3908449360
   ("" (skeep)
    (("" (rewrite "ideal_is_coset")
      (("" (hide 2) (("" (rewrite "zero_ideal") nil nil)) nil)) nil))
    nil)
   ((nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (ideal_is_coset formula-decl nil ring_cosets_lemmas nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (ring? const-decl "bool" ring_def nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas_extras
     nil)
    (s1 formal-const-decl "[T1, T1 -> T1]"
     ring_homomorphism_lemmas_extras nil)
    (p1 formal-const-decl "[T1, T1 -> T1]"
     ring_homomorphism_lemmas_extras nil)
    (zero1 formal-const-decl "T1" ring_homomorphism_lemmas_extras nil)
    (zero_ideal formula-decl nil ring_ideal nil))
   nil
   (zero_natural_isomorphism subtype
    "sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1)"
    "cosets_def[ring_homomorphism_lemmas_extras.T1, ring_homomorphism_lemmas_extras.s1].coset(ring_homomorphism_lemmas_extras.S, sets[ring_homomorphism_lemmas_extras.T1].singleton(ring_homomorphism_lemmas_extras.zero1))")))
 (zero_natural_isomorphism 0
  (zero_natural_isomorphism-1 nil 3908449394
   ("" (skeep)
    (("" (expand "R_isomorphic?")
      (("" (inst 1 "(LAMBDA (r:(S)): r + singleton(zero1))")
        (("1"
          (lemma
           "ring_natural_homo[T1,s1,p1,zero1,coset(S,singleton(zero1)),add(S,singleton(zero1)),product(S,singleton(zero1)),singleton(zero1)]")
          (("1" (inst -1 "S" "singleton(zero1)")
            (("1" (assert)
              (("1" (flatten)
                (("1" (expand "R_isomorphism?")
                  (("1" (assert)
                    (("1"
                      (lemma "monomorphism_charac[T1,s1,p1,zero1,
                                coset(S,singleton(zero1)),add(S,singleton(zero1)),product(S,singleton(zero1)),singleton(zero1)]")
                      (("1"
                        (inst -1 "S" "S/singleton(zero1)"
                         "(LAMBDA (r: (S)): r + singleton(zero1))")
                        (("1" (assert) nil nil)
                         ("2" (hide 2)
                          (("2" (expand "R_epimorphism?")
                            (("2" (assert) nil nil)) nil))
                          nil)
                         ("3" (skeep)
                          (("3" (expand "restrict")
                            (("3" (expand "/")
                              (("3"
                                (hide-all-but 1)
                                (("3"
                                  (rewrite "lcoset_iff_coset" :dir rl)
                                  (("3"
                                    (case
                                     "left_coset?(S, singleton[T1](zero1))
                                               ((+[T1, s1])(r, singleton[T1](zero1)))")
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (hide 2)
                                      (("2"
                                        (expand "left_coset?")
                                        (("2" (inst 1 "r") nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("4" (hide-all-but 1)
                          (("4" (rewrite "quotient_group_is_ring")
                            (("4" (hide 2)
                              (("4" (rewrite "zero_ideal") nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (rewrite "zero_ideal") nil nil))
            nil)
           ("2" (hide 2)
            (("2" (rewrite "fullset_quot_group_is_ring")
              (("2" (hide 2) (("2" (rewrite "zero_ideal") nil nil))
                nil))
              nil))
            nil)
           ("3" (hide 2) (("3" (rewrite " R1_is_ring") nil nil)) nil)
           ("4" (hide 2)
            (("4" (rewrite "ideal_is_coset")
              (("4" (rewrite "zero_ideal") nil nil)) nil))
            nil)
           ("5" (hide 2)
            (("5" (skeep)
              (("5" (lemma "coset_product")
                (("5" (inst -1 "S" "singleton(zero1)" "x1`1" "x1`2")
                  (("1" (assert) nil nil)
                   ("2" (rewrite "zero_ideal") nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("6" (hide 2)
            (("6" (skeep)
              (("6" (lemma "coset_add")
                (("6" (inst -1 "S" "singleton(zero1)" "x1`1" "x1`2")
                  (("1" (assert) nil nil)
                   ("2" (rewrite "zero_ideal") nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("7" (hide 2)
            (("7" (inst 1 "singleton(zero1)")
              (("7" (rewrite "ideal_is_coset")
                (("7" (rewrite "zero_ideal") nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (expand "restrict")
            (("2" (expand "/")
              (("2"
                (case " coset?[T1, s1]
                            (S, singleton[T1](zero1))((+[T1, s1])(r, singleton[T1](zero1)))")
                (("1" (assert) nil nil)
                 ("2" (hide 2)
                  (("2" (rewrite "lcoset_iff_coset" :dir rl)
                    (("2" (expand "left_coset?")
                      (("2" (inst 1 "r") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((R_isomorphic? const-decl "bool" ring_homomorphisms_def nil)
    (ring_natural_homo formula-decl nil ring_homomorphism_lemmas nil)
    (add const-decl "set[T]" cosets_def nil)
    (product const-decl "set[T]" product_coset_def nil)
    (TRUE const-decl "bool" booleans nil)
    (fullset const-decl "set" sets nil)
    (R_isomorphism? const-decl "bool" ring_homomorphisms_def nil)
    (monomorphism_charac formula-decl nil ring_homomorphism_lemmas nil)
    (zero_ideal formula-decl nil ring_ideal nil)
    (quotient_group_is_ring formula-decl nil quotient_rings nil)
    (lcoset_iff_coset formula-decl nil ring_cosets_lemmas nil)
    (left_coset? const-decl "bool" cosets_def nil)
    (R_epimorphism? const-decl "bool" ring_homomorphisms_def nil)
    (R_homomorphism type-eq-decl nil ring_homomorphisms_def nil)
    (R_homomorphism? const-decl "bool" ring_homomorphisms_def nil)
    (ideal type-eq-decl nil ring_ideal_def nil)
    (ideal? const-decl "bool" ring_ideal_def nil)
    (fullset_quot_group_is_ring formula-decl nil quotient_rings nil)
    (R1_is_ring formula-decl nil ring_homomorphism_lemmas_extras nil)
    (ideal_is_coset formula-decl nil ring_cosets_lemmas nil)
    (coset_product formula-decl nil quotient_rings nil)
    (coset_add formula-decl nil quotient_rings nil)
    (T1 formal-nonempty-type-decl nil ring_homomorphism_lemmas_extras
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (set type-eq-decl nil sets nil)
    (s1 formal-const-decl "[T1, T1 -> T1]"
     ring_homomorphism_lemmas_extras nil)
    (p1 formal-const-decl "[T1, T1 -> T1]"
     ring_homomorphism_lemmas_extras nil)
    (zero1 formal-const-decl "T1" ring_homomorphism_lemmas_extras nil)
    (ring? const-decl "bool" ring_def nil)
    (ring nonempty-type-eq-decl nil ring nil)
    (S skolem-const-decl "ring[T1, s1, p1, zero1]"
     ring_homomorphism_lemmas_extras nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (coset? const-decl "bool" cosets_def nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (+ const-decl "set[T]" cosets_def nil)
    (coset type-eq-decl nil cosets_def nil)
    (restrict const-decl "R" restrict nil)
    (setof type-eq-decl nil defined_types nil)
    (/ const-decl "setof[set[T]]" cosets_def nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil))
   shostak)))

